---
title: "Sample Clustering"
author: "Sarah Killcoyne"
date: "12/6/2016"
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(GGally)
library(plyr)
library(xlsx)
library(dplyr)
library(pander)
library(Hmisc)
library(ggdendro)
library(reshape2)
library(GenomicRanges)
library(gridExtra)
library(biomaRt)

library(tibble)
library(mclust)

source('lib/load_patient_metadata.R')

getPrecision<-function(actual,predicted) {
  retrieved <- sum(predicted==1)
  precision <- sum(predicted==1 & actual==1) / retrieved
  precision
}
getRecall<-function(actual,predicted) {
  retrieved <- sum(predicted==1)
  recall <- sum(predicted==1 & actual==1) / sum(actual==1)
  recall
}


data = '~/Data/Ellie'

data.files = list.files(paste(data, 'QDNAseq',sep='/'), full.names=T)
plot.dir = paste(data, 'Analysis/multipcf_plots_fitted_perPatient', sep='/')

if (length(list.files(plot.dir)) <= 0)
  stop(paste("No analysis files found in", plot.dir ))

## Patient info file
patient.file = grep('All_patient_info.xls', data.files, value=T)
if (length(patient.file) != 1)
  stop(paste("Missing/too many patient info file(s) in", data))

patient.info = read.patient.info(patient.file)

patient.info$Patient = gsub("/", "_", patient.info$Patient)
#head(patient.info)

patient.info = arrange(patient.info, Status, Patient, Endoscopy.Year, Pathology)

sum.patient.data = ddply(patient.info, .(Patient, Status), summarise, years=paste(range(Endoscopy.Year), collapse='-'), 
      n.samples=length(Samplename), med.cellularity=median(Barretts.Cellularity,na.rm=T))

load('patients.Rdata', verbose=T)
```

## How do the sample timepoints separate?

It appears that in the progressors that generally the HGD or IMC pathology may suddenly appear and be very different (PR1-HIN-044) from other samples, or those where it may have been a progressive sampling that can be fairly related to previous samples (AHM0952).  In most cases the HGD/IMC samples drive the variance, but it is often there in the LGD samples as well.  In contrast the non-progressor patients, even where they have LGD, don't generally show a sudden jump in the sample (AD0591).  

This would suggest we might have a more difficult time separating out the progressors where the early samples were all highly related and a sudden shift occurred to generate the HGD sample. This could be either sampling bias or a sudden model of progression, but I can't think of a method right now that might separate the two.

```{r pca, echo=F, warning=F, message=F, fig.width=20, fig.height=20}
sum.patient.data = arrange(sum.patient.data, Status, n.samples)

plot.pca<-function(pt) {
  
  info = arrange(patient.data[[pt]]$info, Endoscopy.Year)
  
  x1 = patient.data[[pt]]$seg.vals[, patient.data[[pt]]$info$Samplename]
  x1 = x1[,patient.data[[pt]]$info$Samplename]
  colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )
  
  pca = prcomp(t(x1), scale=T)
  
  eigenvalues = pca$sdev^2
  #screeplot(pca, main='scree')
  
  #plot(pca$sd^2)

  df = as.data.frame(pca$x)
  df$year = as.factor(info$Endoscopy.Year)
  df$label = paste(info$Endoscopy.Year, '(', info$Pathology, ')', sep='' )
  df$Pathology = info$Pathology

  gg = ggplot(df, aes(PC1, PC2)) + geom_line() +
    geom_label(aes(label=year),nudge_y=0.04) + 
    geom_point( aes(color=Pathology, size=Pathology)) +
    labs(title=pt)

  return(gg)
}


pplots = lapply(subset(sum.patient.data, Status == 'P')$Patient, plot.pca)
grid.arrange(grobs=pplots, ncol=2, top="Progressors")

npplots = lapply(subset(sum.patient.data, Status == 'NP')$Patient, plot.pca)
grid.arrange(grobs=npplots, ncol=2, top="Non-Progressors")

```

## Mixture Models

One of the questions we'd like to answer is how to separate the progressors from the non-progressors before we see the pathological progression (HGD or even LGD).  If there is increasing instability in the genome how do we characterize it?

I tried were several mixture models (e.g. EM) but wasn't able to find a pattern that could reliably separate the few mixtures I did see

```{r clust, echo=T, message=T, warning=F, eval=T, fig.height=6, fig.width=6}

llk = vector(mode='numeric', length=nrow(sum.patient.data))
names(llk) = sum.patient.data$Patient
for (pt in sum.patient.data$Patient) {
  print(pt)
  print(ncol(patient.data[[pt]]$seg.vals[,-(1:5)]))
  
  x1 = as.matrix(patient.data[[pt]]$seg.vals[,-(1:5)])
  x1 = x1[,patient.data[[pt]]$info$Samplename]
  
  fit <- Mclust(x1, G=3)
  plot(fit, what='classification')
  title(main=paste(pt, ' (',patient.data[[pt]]$info$Status[1], ')', sep=''))

  llk[pt] = fit$loglik
  
  
#   clusterPlots <- data.frame(x1 = clusterData$x1, x2 = clusterData$x2, cluster = factor(model$classification, 
#     levels = c(1, 2), labels = c("z = 0", "z = 1")), uncertainity = model$uncertainty, 
#     logUncertainity = log(model$uncertainty))
# clusterPlots.gg <- ggplot(clusterPlots)
# clusterPlots.gg + geom_point(aes(x = x1, y = x2, color = cluster))
  
  
  #tryCatch({
  # model = densityMclust(x1, G=3)
  # plotDensityMclustd(model, data=x1,  col='blue', lwd=2, hist.col = "lightblue",  breaks=100)
  #   mod1dr = MclustDR(model, lambda = 0.5)
  #   #summary(mod1dr)
  #   table(mod1dr$mixcomp)
  # 
  #   #plot(mod1dr, what = "evalues")
  #   #title(main=pt)
  #   plot(mod1dr, what = "density")
  #   title(main=paste(pt, ' (',patient.data[[pt]]$info$Status[1], ')', sep=''))
  # })
}

# Log liklihood doesn't separate them
t.test(llk[subset(sum.patient.data, Status == 'NP')$Patient], llk[subset(sum.patient.data, Status == 'P')$Patient])

```


```{r means, echo=F, message=F, warning=F, eval=F} 
## Kmeans
#   x1 = as.matrix(patient.data[[pt]]$seg.vals[,-(1:5)])
# 
   fit = kmeans(x1, 3)
#   plot(x1[,c(1,10)], col=km$cluster)
# title(main=paste(pt, ' (',patient.data[[pt]]$info$Status[1], ')', sep=''))  


library(cluster) 
clusplot(x1, fit$cluster, color=TRUE, shade=TRUE, labels=2, lines=0, main=pt)


```


```{r apclust-func, echo=F, message=F, warning=F}
suppressPackageStartupMessages( library(apcluster) )

apclust.data<-function(segdata, samples) {
  x1 = segdata[,intersect(colnames(segdata), samples)]
  x1 = x1[, samples]
  rownames(x1) = (segdata[,c(1:4)] %>%
    rowwise() %>%
    mutate(location=paste(paste(chrom, arm, sep=''), '.', start.pos, '-', end.pos, sep='')))$location
  return(x1)  
}

apclust<-function(segdata) {
  x1 = apclust.data(segdata)
  # q=0 minimize off-diagonal similarity
  ac = apcluster(negDistMat(r=2), x1, details=T, convits=25, q=0)
  return(list('apres'=ac, 'data'=x1))
}

net.similarity<-function(ac) {
  if (is.list(ac))
    ac = ac$apres
  ac@netsim
}

sum.similarity<-function(ac) {
  if (is.list(ac))
    ac = ac$apres
  ac@dpsim
}

clusters<-function(ac) {
  if (is.list(ac))
    ac = ac$apres
  ac@exemplars
}

plotAC<-function(aclist) {
  plot(aclist$apres, aclist$data)
} 

heatmapAC<-function(aclist) {
  heatmap(aclist$apres)
}

# First vs last samples
#x1 = apclust.data(patient.data[[pt]]$seg.vals[,c(1:4, 6, ncol(patient.data[[pt]]$seg.vals))], patient.data[[pt]]$info$Samplename)
```






```{r clustN, echo=T, message=T, warning=F, eval=F}
## Normalized Segmentation Values
#Doesn't work for the normalized values.  

for (pt in subset(sum.patient.data, Status == 'P')$Patient) {
  if (pt == 'AH0254') next
  print(pt)
  print(paste('norm.seg.vals cols:', ncol(patient.data[[pt]]$norm.seg.vals)))
  
  x1 = patient.data[[pt]]$norm.seg.vals
  model = Mclust(t(x1))
  print(paste('loglik', round(model$loglik,2)))
  
  tryCatch({
    mod1dr = MclustDR(model, lambda = 1)
    #summary(mod1dr)
    table(mod1dr$mixcomp)
  
    if (length(table(mod1dr$mixcomp)) > 1) {
      plot(mod1dr, what = "evalues")
      title(main=pt)
      plot(mod1dr, what = "density")
    }
  })
}


```

## AP Clustering

So tried AP as that doesn't require the pre-definition for number of clusters.  It appears to give good separation, though there's a suggestion of two different types of progressors.

### Affinity Propagagion clustering described by Frey & Dueck, 2007

First on the raw segmentation values

```{r apclust, echo=T, message=T, warning=F, fig.height=10, fig.width=10, fig.align='left'}
q=0.2

sum.patient.data = arrange(sum.patient.data, Status)

## Using the segmentation values
sim = sum.patient.data[,c(2:4)]
rownames(sim) = sum.patient.data[,1]
for (pt in sum.patient.data$Patient) {
  patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, desc(Pathology))

  x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
  colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )

  ac = apcluster(negDistMat(x1, r=2), q=q, details=T, includeSim=T)
  
  last = ncol(x1)
  if (patient.data[[pt]]$info$Status[1] == 'P' & pt != 'AD0252')
    last = sort(grep('HGD|IMC', patient.data[[pt]]$info$Pathology), decreasing=T)[1]
  if (ncol(x1) <= 15) {
    plot(ac, x1[,c(c(1:ncol(x1))[-last], last)], main=pt)
  } else {
    plot(ac, x1[,c(1, sort(sample(c(1:(ncol(x1)-1))[c(-1,-last)], 8)) ,last) ], main=pt)
  }

  sim[pt, 'ns'] = net.similarity(ac)
  sim[pt, 'ss'] = sum.similarity(ac)
  sim[pt, 'clusters'] = length(clusters(ac))
  #heatmap(ac)
}
sim$id = rownames(sim)

sm = as.data.frame(summarise(group_by(sim, Status), mean.ns=mean(ns), sd.ns=sd(ns), mean.ss=mean(ss), sd.ss=sd(ss), mean.c=mean(clusters), sd.c=sd(clusters) ))

# May be a difference
ttps = t.test( subset(sim, Status == 'NP')$ss, subset(sim, Status == 'P')$ss )$p.value
ttpn = t.test( subset(sim, Status == 'NP')$ns, subset(sim, Status == 'P')$ns )$p.value
ttpc = t.test( subset(sim, Status == 'NP')$clusters, subset(sim, Status == 'P')$clusters )$p.value

#t.test( subset(sim, Status == 'NP')$clusters, subset(sim, Status == 'P')$clusters )$p.value

g1 = ggplot(sim[,c('Status','ss')], aes(y=ss, x=Status, fill=Status)) + geom_boxplot() + 
  geom_jitter(width=0.2) + stat_boxplot(geom ='errorbar') +
  labs(title=paste("p-value", signif(ttps, 3)), y='sum similarity')

g2 = ggplot(sim[,c('Status','clusters')], aes(y=clusters, x=Status, fill=Status)) + geom_boxplot() + 
  geom_jitter(width=0.2) + stat_boxplot(geom ='errorbar') +
  labs(title=paste("p-value", signif(ttpc, 3)), y='num. clusters')

grid.arrange(g1, g2, top='Raw seg values')


fit = glm(Status~clusters, sim, family=binomial(link='logit'))
pander(fit, justify='left')

sim = sim[, c('Status', 'clusters', 'ns','ss')]
actualMatrix = matrix(0,1000,2,dimnames=list(c(), c('prec','recall')))
for (i in 1:nrow(actualMatrix)) {
  trainingRows = sample(1:nrow(sim), nrow(sim)-5)
  train = sim[trainingRows,]
  test = sim[-trainingRows,]
  
  fit = glm( (as.integer(Status)-1)~clusters, train, family=binomial(link='logit'))
  pred = predict(fit, test, se.fit=F) # probabilities -- of which outcome though?
  
  actual = test$Status == 'P'
  predicted = pred>0
  
  actualMatrix[i,'prec'] = getPrecision( actual, predicted )
  actualMatrix[i, 'recall'] = getRecall( actual, predicted )
}

ggplot(as.data.frame(actualMatrix), aes(x=recall, y=prec)) + geom_point() + 
  geom_hline(yintercept = 0.5, col='red', alpha=0.5) +
  labs(title='Precision/Recall for Progressor/NP prediction')

```

### Are the clusters random?

```{r example_pt}
pt = 'PR1_HIN_042'
patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, desc(Pathology))

x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )

ac = apcluster(negDistMat(x1, r=2), q=q, details=T, includeSim=T)

cols = c('chr','cluster','P.x', 'x')
hgmx = matrix(nrow=0,ncol=length(cols),dimnames=list(c(), cols))
for (chr in c(1:22)) {
  for (i in 1:length(ac@clusters)) {
    cl = x1[ac@clusters[[i]],]  
    
    x = length(grep(paste('^',chr,'(p|q)',sep=''),  rownames(cl), value=T)) # n in cluster
    m = length(grep(paste('^',chr,'(p|q)',sep=''),  rownames(x1), value=T)) # total n
    n = nrow(x1)-m
    k = length(ac@clusters[[i]])

    hgmx = rbind(hgmx, cbind(chr, i, signif(dhyper(x,m,n,k),3), x))
  }
}

hgmx = as.data.frame(hgmx)

ggplot(subset(hgmx, x > 0), aes(x=chr,y=P.x,color=factor(cluster))) + ylim(0,1)+ 
  geom_point() + geom_line(alpha=0.1)

ggplot(subset(hgmx, x > 0 & cluster == 9), aes(x=factor(chr),y=P.x,fill=factor(cluster))) + ylim(0,0.5 )+ 
  geom_bar(colour='grey', stat='identity', position=position_dodge())


```



So what about using the normalized segmented values?

```{r apclustN, echo=T, message=T, warning=F, fig.height=8, fig.align='left'}
# Should this be performed on the normalized seg values instead?
sim3 = sum.patient.data[,c(2:4)]
rownames(sim3) = sum.patient.data[,1]
for (pt in sum.patient.data$Patient) {
  x1 = patient.data[[pt]]$norm.seg.vals
  ac = apcluster(negDistMat(x1, r=2), q=q, details=T, includeSim=T)
  #plot(ac)
  
  sim3[pt, 'ss'] = sum.similarity(ac)
  sim3[pt, 'ns'] = net.similarity(ac)
  sim3[pt, 'clusters'] = length(clusters(ac))
}

summarise(group_by(sim3, Status), mean.ns=mean(ns), sd.ns=sd(ns), mean.c=mean(clusters), sd.c=sd(clusters) )

# Doesn't show up here
ttp = t.test( subset(sim3, Status == 'NP')$ss, subset(sim3, Status == 'P')$ss )$p.value
#ttp = t.test( subset(sim3, Status == 'NP')$ns, subset(sim3, Status == 'P')$ns )$p.value
ttc = t.test( subset(sim3, Status == 'NP')$clusters, subset(sim3, Status == 'P')$clusters )$p.value

ggplot(sim3[,c('Status','ss')], aes(y=ss, x=Status, fill=Status)) + geom_boxplot() + geom_jitter(width=0.2) + 
  labs(title=paste("Norm seg values p-value", signif(ttp, 3)), y='sum similarity')
```

So using the raw segmentation values (not the normalized ones) try some leave one out xval to see if the currently weak differences still hold.

Patients first

```{r xval_pt, echo=T, warning=F, message=T, fig.align='left', fig.height=4, eval=T}
# Leave out patients
loo_xval = matrix(ncol=3, nrow=0, dimnames=list(c(), c('net.similarity', 'sum.similarity', 'clusters')))
for (i in 1:nrow(sum.patient.data)) {
  simL = sum.patient.data[-i,c(2:4)]
  rownames(simL) = sum.patient.data[-i,1]

  for (pt in sum.patient.data$Patient[-i]) {
    x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
    ac = apcluster(negDistMat(x1, r=2), q=q)
  
    simL[pt, 'ns'] = net.similarity(ac)
    simL[pt, 'ss'] = sum.similarity(ac)
    simL[pt, 'clusters'] = length(clusters(ac))
  }
  
  ttps = t.test( subset(simL, Status == 'NP')$ss, subset(simL, Status == 'P')$ss )$p.value
  ttpn = t.test( subset(simL, Status == 'NP')$ns, subset(simL, Status == 'P')$ns )$p.value
  ttc = t.test( subset(simL, Status == 'NP')$clusters, subset(simL, Status == 'P')$clusters )$p.value

  loo_xval = rbind(loo_xval, cbind(ttpn, ttps, ttc))
}

ggplot(melt(data.frame(loo_xval[,c(1,3)])), aes(x=variable, y=value, fill=variable)) +  
    geom_boxplot() + geom_jitter(shape=16, width=0.2) + geom_hline(yintercept=0.05, color='red', alpha=0.5) +
    stat_boxplot(geom ='errorbar') + labs(y='p-values', x='', title='Leave one (patient) out clustering')
```

Then randomly leave out samples

```{r xval_smp, echo=F, warning=F, message=T, fig.align='left', fig.height=6, eval=T}

# Leave out samples?
looS_xval = matrix(ncol=3, nrow=0, dimnames=list(c(), c('net.similarity', 'sum.similarity', 'clusters')))
for (i in 1:20) { 
  simX = sum.patient.data[,c(2:4)]
  rownames(simX) = sum.patient.data[,1]
  
  for (pt in sum.patient.data$Patient) {
      x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename[-sample(1:(length(patient.data[[pt]]$info$Samplename)), 1)])
      ac = apcluster(negDistMat(x1, r=2), q=q)
  
      simX[pt, 'ns'] = net.similarity(ac)
      simX[pt, 'ss'] = sum.similarity(ac)
      simX[pt, 'clusters'] = length(clusters(ac))
    }
  
  ttpn = t.test( subset(simX, Status == 'NP')$ns, subset(simX, Status == 'P')$ns )$p.value
  ttps = t.test( subset(simX, Status == 'NP')$ss, subset(simX, Status == 'P')$ss )$p.value
  ttc = t.test( subset(simX, Status == 'NP')$clusters, subset(simX, Status == 'P')$clusters )$p.value

  looS_xval = rbind(looS_xval, cbind(ttpn,ttps, ttc))
}

ggplot(melt(data.frame(looS_xval[,c(2,3)])), aes(x=variable, y=value, fill=variable)) +  
    geom_boxplot() + geom_jitter(shape=16, position=position_jitter(0.2)) +
  geom_hline(yintercept=0.05, color='red', alpha=0.5) +
    stat_boxplot(geom ='errorbar') + labs(y='p-values', x='', title='Leave one (sample) out clustering')
```

## (xval) Re run clusters on the Progressors without the HGD sample
There is still a difference between the progressors and non, though the p-value does increase. Some of the progressors do start looking more like NPs in their similarity measure but not all of them.

```{r nofinal, echo=F, message=F, warning=F, fig.height=6, fig.width=10}
simX = sum.patient.data[,c(2:4)]
rownames(simX) = sum.patient.data[,1]
# Leave out final sample on the progressors 

for (pt in sum.patient.data$Patient) {
  x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
  if (subset(sum.patient.data, Patient == pt)$Status == 'P' & length(which(grepl('HGD|IMC', patient.data[[pt]]$info$Pathology))) > 0) {
    final = grep('HGD|IMC', patient.data[[pt]]$info$Pathology)
    x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename[-final])
  }
  ac = apcluster(negDistMat(x1, r=2), q=q)
  
  simX[pt, 'ns'] = net.similarity(ac)
  simX[pt, 'ss'] = sum.similarity(ac)
  simX[pt, 'clusters'] = length(clusters(ac))
}
  
ttps = t.test( subset(simX, Status == 'NP')$ss, subset(simX, Status == 'P')$ss )$p.value
gg1 = ggplot(melt(data.frame(simX[c('Status','ss')])), aes(x=Status, y=value, fill=Status)) +  
    geom_boxplot() + geom_jitter(shape=16, position=position_jitter(0.2)) +
    stat_boxplot(geom ='errorbar') + labs(y='sim values', x='', title=paste('Leave out HGD sample(s) p-value', signif(ttps, 3)))

ttpc = t.test( subset(simX, Status == 'NP')$clusters, subset(simX, Status == 'P')$clusters )$p.value
gg2 = ggplot(melt(data.frame(simX[c('Status','clusters')])), aes(x=Status, y=value, fill=Status)) +  
    geom_boxplot() + geom_jitter(shape=16, position=position_jitter(0.2)) +
    stat_boxplot(geom ='errorbar') + labs(y='num. clusters', x='', title=paste('Leave out HGD sample(s) p-value', signif(ttpc, 3)))

grid.arrange(gg1, gg2, ncol=2)

#pander(subset(simX, Status == 'P' & ss <= mean(ss)), caption="These patients are still strongly in the Progressor group")

pander(subset(simX, Status == 'P' & ss >= mean(ss)), caption="These patients are more similar to Non-Progressors without their HGD sample(s)")


simX = simX[, c('Status', 'clusters', 'ns','ss')]
noHGDPR = as.data.frame(matrix(0,1000,2,dimnames=list(c(), c('prec','recall'))))
for (i in 1:nrow(actualMatrix)) {
  trainingRows = sample(1:nrow(simX), nrow(simX)-5)
  train = simX[trainingRows,]
  test = simX[-trainingRows,]
  
  fit = glm( Status~clusters, train, family=binomial(link='logit'))
  pred = predict(fit, test, se.fit=F) # probabilities -- of which outcome though?
  
  actual = test$Status == 'P'
  predicted = pred>0
  
  noHGDPR[i,'prec'] = getPrecision( actual, predicted )
  noHGDPR[i, 'recall'] = getRecall( actual, predicted )
}

ggplot(as.data.frame(noHGDPR), aes(x=recall, y=prec)) + geom_point() + 
  geom_hline(yintercept = 0.5, col='red', alpha=0.5) +
  labs(title='Precision/Recall for Progressor/NP prediction NO HGD')




```

Currently, without the HGD/IMC samples we can predict progressors `r nrow(subset(noHGDPR, prec > 0.5))/nrow(noHGDPR)*100`% of the time.
In comparison, including HGD/IMC samples our predictions improve to `r length(which(actualMatrix[,'prec'] > 0.5))/nrow(actualMatrix)*100`%.

 
## And why q=0.2
```{r whyq, echo=F, message=F, warning=F}
sum.patient.data = arrange(sum.patient.data, Status)

pvals = as.data.frame(matrix(ncol=2,nrow=0,dimnames=list(c(), c('clusters','ss'))))
for (qv in seq(0.1,0.9,0.1)) {
  print(qv)
  
  ## Using the segmentation values
  simPC = sum.patient.data[,c(2:4)]
  rownames(simPC) = sum.patient.data[,1]
  for (pt in sum.patient.data$Patient) {
    patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, desc(Pathology))
  
    x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
    colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )
  
    ac = apcluster(negDistMat(x1, r=2), q=qv, convits=75)
    
    simPC[pt, 'ns'] = net.similarity(ac)
    simPC[pt, 'ss'] = sum.similarity(ac)
    simPC[pt, 'clusters'] = length(clusters(ac))
  }
  
  # May be a difference
  ttps = t.test( subset(simPC, Status == 'NP')$ss, subset(simPC, Status == 'P')$ss )$p.value
  ttpn = t.test( subset(simPC, Status == 'NP')$ns, subset(simPC, Status == 'P')$ns )$p.value
  ttpc = t.test( subset(simPC, Status == 'NP')$clusters, subset(simPC, Status == 'P')$clusters )$p.value

  pvals = rbind(pvals,cbind(ttpc,ttps))
}
colnames(pvals) = c('clusters','sum.similarity')
pvals$qv=seq(0.1,0.9,0.1)


ggplot(melt(pvals, id.vars='qv'),aes(x=qv,y=value, color=variable)) + geom_point() +
  labs(main="qvalus for AP", y='pvalue NP vs P', x='q param')
  

```


```{r loc_pca, echo=F, warning=F, message=T, fig.height=12, fig.width=20, eval=F}
## Can we identify regions in the progressors?

#Not really just from the SVDs.  This isn't any different at the moment from simply calling the variable regions directly.

count.occurrences<-function(grs) {
  ov = findOverlaps(grs, type="within", ignoreSelf=TRUE,select="arbitrary")
  counts = countOverlaps(grs, type='within', maxgap=0)

  newgrs = grs[is.na(ov)]
  
  newgrs$overlaps = 0
  newgrs$patients = ''

  patients = c()  
  index = 1
  occurence = vector(mode='numeric')
  for (x in which(is.na(ov))) {
    occurence = c(occurence, sum(count[index:x]))
    patients = c(patients, paste(grs[index:x]$patient, collapse=','))
    index = x+1
  }
  newgrs$overlaps = occurence
  newgrs$patients = patients

  newgrs$patient.count = unlist(lapply(strsplit(patients, ','), length))
  
  newgrs$patient = NULL  
  return(newgrs)
}
annotate.cosmic<-function(grs) {
  ccgenes = read.table('~/Data/CosmicCensusGenes.tsv', sep='\t', header=T, stringsAsFactors=F)
  ensembl = biomaRt::useMart("ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org")
  mart = useDataset("hsapiens_gene_ensembl", ensembl)
  
  grs$Genes = 0
  grs$Cosmic.count = 0
  grs$Cosmic.genes = ''
  
  plocs = as.data.frame(grs)  
  for (i in 1:nrow(plocs)) {
    bm = getBM(mart = mart,
        attributes=c('hgnc_symbol', 'entrezgene' ), filters = c('chromosome_name', 'start', 'end' ),
        values = with(plocs[i,], list(gsub("chr", "", as.character(seqnames)), start, end)))

    grs[i]$Genes = length(unique(bm$hgnc_symbol))
    grs[i]$Cosmic.count = length(intersect(bm$entrezgene, ccgenes$Entrez.GeneId))
    grs[i]$Cosmic.genes = paste(intersect(bm$hgnc_symbol, ccgenes$Gene.Symbol), collapse=',')
  }

  return(grs)
}

#pt = 'PR1_HIN_042'
gg.svd<-function(mat, names, sd=0, n=3) {
  df = as.data.frame(mat[,(1:n)])
  
  for (i in 1:ncol(df)) {
    high = mat[,i] > (mean(mat[,i]) + sd * sd(mat[,i]))
    low = mat[,i] < (mean(mat[,i]) - sd * sd(mat[,i]))
  
    label = high | low
    color=label
  
    for (j in 1:length(label))
      label[j] = ifelse(label[j], names[j], '')
  
    df = cbind(df, label, color)
    colnames(df)[grep('^label$', colnames(df))] = paste('SV',i,'.label',sep='')
    colnames(df)[grep('^color$', colnames(df))] = paste('SV',i,'.color',sep='')
  }
  df$x = 1:nrow(df)
  return(df)
  }

pt.regions = list()
for (pt in sum.patient.data$Patient) {
  print(pt)
  patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, Pathology)

  x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
  colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )

  #plot.pca(pt)
  #pca = prcomp(t(x1), center=T)
  
  #plot(pca$sdev^2, type='o')
  
  svd = svd(t(x1))
  colnames(svd$u) = paste('SV',1:ncol(svd$u), sep='') 
  colnames(svd$v) = paste('SV',1:ncol(svd$v), sep='') 

  #plot(svd$d, type='o', main='Scree')
  # u matrix
  samples = gg.svd(svd$u, colnames(x1), 0, 3)
  grid.arrange(
    ggplot(samples, aes(y=SV1, x=x, col=SV1.color)) + geom_point() +
      geom_text(aes(label=SV1.label), vjust=0) + guides(color='none'),
    ggplot(samples, aes(y=SV2, x=x, col=SV2.color)) + geom_point() +
      geom_text(aes(label=SV2.label), vjust=0) + guides(color='none'),
    ggplot(samples, aes(y=SV3, x=x, col=SV3.color)) + geom_point() +
      geom_text(aes(label=SV3.label), vjust=0) + guides(color='none'),
    top='SVD Samples')
  
  # v matrix
  regions = gg.svd(svd$v, rownames(x1), 2, 3)
  grid.arrange(
    ggplot(regions, aes(y=SV1, x=x, col=SV1.color)) + geom_point() +
      geom_text(aes(label=SV1.label), vjust=0) + guides(color='none'),
    ggplot(regions, aes(y=SV2, x=x, col=SV2.color)) + geom_point() +
      geom_text(aes(label=SV2.label), vjust=0) + guides(color='none'),
    ggplot(regions, aes(y=SV3, x=x, col=SV3.color)) + geom_point() +
      geom_text(aes(label=SV3.label), vjust=0) + guides(color='none'), 
    top='SVD Locations')
  
  locs = as.character(unlist(c(regions[grep('SV1.label',colnames(regions))])))
  locs = unique(locs[grep("\\w+", locs)])


  high = names(which(apply(x1[locs,], 1, function(x) length(which(x >= 1.1))) > 0))
  low = names(which(apply(x1[locs,], 1, function(x) length(which(x <= 0.9))) > 0))

  hls = as.data.frame(do.call(rbind, strsplit(c(high, low), '[p|q]\\.|-')))
  colnames(hls) = c('chr','start','stop')
  hls[c('start','stop')] = lapply(hls[c('start','stop')], function(x) as.numeric(as.character(x))) 
  
  #ac = apcluster(negDistMat(x1, r=2), q=0.2)

  #lapply(ac@clusters, function(x) names(x)[which(names(x) %in% high)])
  #lapply(ac@clusters, function(x) names(x)[which(names(x) %in% low)])

  pt.regions[[pt]] = data.frame(hls, cn=c(rep('gain', length(high)), rep('loss',length(low))))
}
pt.regions = do.call(rbind, pt.regions)

pt.regions$patient = sub('\\..*', '', rownames(pt.regions) )
rownames(pt.regions) = 1:nrow(pt.regions)

prog.grs = sort(makeGRangesFromDataFrame(subset(pt.regions, patient %in% subset(sum.patient.data, Status == 'P')$Patient), keep.extra.columns = T, seqnames.field = 'chr', seqinfo=c(1:22,'X','Y')))

np.grs = sort(makeGRangesFromDataFrame(subset(pt.regions, patient %in% subset(sum.patient.data, Status == 'NP')$Patient), keep.extra.columns = T, seqnames.field = 'chr', seqinfo=c(1:22,'X','Y')))


prog.loss = count.occurrences(subset(prog.grs, grepl('loss',cn)))
prog.gain = count.occurrences(subset(prog.grs, grepl('gain',cn)))

np.loss = count.occurrences(subset(np.grs, grepl('loss',cn)))
np.gain = count.occurrences(subset(np.grs, grepl('gain',cn)))


pg.c = annotate.cosmic(prog.gain)
pl.c = annotate.cosmic(prog.loss)

npg.c = annotate.cosmic(np.gain)
npl.c = annotate.cosmic(np.loss)


with(pg.c,plot(overlaps, Cosmic.count, col='blue', pch=19))
with(pl.c, points(overlaps, Cosmic.count, col='red', pch=19))

with(npg.c, points(overlaps, Cosmic.count, col='green', pch=18))
with(npl.c, points(overlaps, Cosmic.count, col='purple', pch=17))

pander(data.frame('total.p' = sum(length(pg.c), length(pl.c)), 'total.np' = sum(length(npg.c), length(npl.c))), caption="Total regions called as gains/losses for progressors vs non")

t.test( width(pg.c), width(npg.c) ) # Yes for the gains
t.test( width(pl.c), width(npl.c) ) # Not for the losses

```


```{r precrec, echo=F, warning=F, message=F, fig.height=12, fig.width=20}






```
