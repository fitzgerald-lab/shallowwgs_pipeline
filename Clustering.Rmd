---
title: "Sample Clustering"
author: "Sarah Killcoyne"
date: "23/02/2016"
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(GGally)
library(plyr)
library(xlsx)
library(dplyr)
library(pander)
library(Hmisc)
library(ggdendro)
library(reshape2)
library(GenomicRanges)
library(gridExtra)
library(biomaRt)
library(multtest)
library(tibble)
library(mclust)

source('lib/load_patient_metadata.R')

getPrecision<-function(actual,predicted) {
  retrieved <- sum(predicted==1)
  precision <- sum(predicted==1 & actual==1) / retrieved
  precision
}
getRecall<-function(actual,predicted) {
  retrieved <- sum(predicted==1)
  recall <- sum(predicted==1 & actual==1) / sum(actual==1)
  recall
}


data = '~/Data/Ellie'

data.files = list.files(paste(data, 'QDNAseq',sep='/'), full.names=T)
plot.dir = paste(data, 'Analysis/multipcf_plots_fitted_perPatient', sep='/')

if (length(list.files(plot.dir)) <= 0)
  stop(paste("No analysis files found in", plot.dir ))

## Patient info file
patient.file = grep('All_patient_info.xls', data.files, value=T)
if (length(patient.file) != 1)
  stop(paste("Missing/too many patient info file(s) in", data))

load('patients.Rdata', verbose=T)

patient.info = read.patient.info(patient.file)

patient.info$Patient = gsub("/", "_", patient.info$Patient)
#head(patient.info)

patient.info = arrange(patient.info, Status, Patient, Endoscopy.Year, Pathology)

sum.patient.data = summarise.patient.info(patient.info)
sum.patient.data = as.data.frame(subset(sum.patient.data, Initial.Analysis)) ## For now
pander(sum.patient.data)
```

# Global View and Questions

```{r global_pt, echo=F, message=F, warning=F}
be = subset(patient.info, Pathology == 'BE')
lgd = subset(patient.info, Pathology <= 'LGD')

p53Status = data.frame(rbind('Non-Progressors'=table(subset(patient.info, Status == 'NP')$p53.Status), 
           'Progressors'=table(subset(patient.info, Status == 'P')$p53.Status)))
colnames(p53Status) = c('None', 'Positive')

set.seed(99)
mtp1 = MTP(X=t(patient.info[,c('Barretts.Cellularity','Total.Reads')]), Y=as.integer((as.integer(patient.info$Pathology) > 3)), robust=T, get.adjp=T, na.rm=T)
mtp2 = MTP(X=t(patient.info[,c('Barretts.Cellularity','Total.Reads')]), Y=patient.info$Status, robust=T, get.adjp=T, na.rm=T)
```

Currently with multi test correction the samples for which cellularity and #of reads are available show no difference for either status (P vs NP)
`r pander(summary(mtp1), justify='left')`

or for samples that are LGD/IMC/HGD vs BE
`r pander(summary(mtp1), justify='left')`


With regards to p53 staining, non-progressors have no p53 positive tests, while progressors had `r p53Status[2,2]` overall.
`r pander(p53Status, justify='left', caption="P53 staining status for progressors vs non")`
Of these `r table(be$p53.Status)[['1']]` were positive in a BE sample, and `r table(lgd$p53.Status)[['1']]` were positive when LGD samples were included.

## How do the sample timepoints separate?

It appears that in the progressors that generally the HGD or IMC pathology may suddenly appear and be very different (PR1-HIN-044) from other samples, or those where it may have been a progressive sampling that can be fairly related to previous samples (AHM0952).  In most cases the HGD/IMC samples drive the variance, but it is often there in the LGD samples as well.  In contrast the non-progressor patients, even where they have LGD, don't generally show a sudden jump in the sample (AD0591).  

This would suggest we might have a more difficult time separating out the progressors where the early samples were all highly related and a sudden shift occurred to generate the HGD sample. This could be either sampling bias or a sudden model of progression, but I can't think of a method right now that might separate the two.

```{r pca, echo=F, warning=F, message=F, fig.width=20, fig.height=40}
sum.patient.data = arrange(sum.patient.data, Status, total.samples)

plot.pca<-function(pt) {

  info = arrange(patient.data[[pt]]$info, Endoscopy.Year)

  plots = list()
  for (sv in c('seg.vals','norm.seg.vals')) {
    
    x1 = patient.data[[pt]][[sv]][, patient.data[[pt]]$info$Samplename]
    x1 = x1[,patient.data[[pt]]$info$Samplename]
    colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )
  
    pca = prcomp(t(x1), scale=T)
  
    eigenvalues = pca$sdev^2
    screeplot(pca, main=paste(pt, sv, 'scree'))
  
    #plot(pca$sd^2)

    df = as.data.frame(pca$x)
    df$year = as.factor(info$Endoscopy.Year)
    df$label = paste(info$Endoscopy.Year, '(', info$Pathology, ')', sep='' )
    df$Pathology = info$Pathology

    gg = ggplot(df, aes(PC1, PC2)) + geom_line() +
        geom_label(aes(label=year),nudge_y=0.04) + 
        geom_point( aes(color=Pathology, size=Pathology)) +
        labs(title=paste(pt, sv))
  plots[[sv]] = gg
  }  
  ga = do.call(grid.arrange, c(plots, list(ncol=2)))
  return(ga)
}

pplots = lapply(subset(sum.patient.data, Status == 'P')$Patient, plot.pca)
grid.arrange(grobs=pplots, nrow=length(subset(sum.patient.data, Status == 'P')$Patient), top="Progressors")

npplots = lapply(subset(sum.patient.data, Status == 'NP')$Patient, plot.pca)
grid.arrange(grobs=npplots, nrow=length(subset(sum.patient.data, Status == 'NP')$Patient), top="Non-Progressors")

```

## Mixture Models

One of the questions we'd like to answer is how to separate the progressors from the non-progressors before we see the pathological progression (HGD or even LGD).  If there is increasing instability in the genome how do we characterize it?

I tried were several mixture models (e.g. EM, kmeans) but wasn't able to find a pattern that could reliably separate the few mixtures I did see

### Raw segmented values 

#### EM
```{r clust, echo=T, message=T, warning=F, eval=T, fig.height=4, fig.width=4, eval=T}

em.dr<-function(patient, status, x1, var.regions) {
  clusters=c(2:4)
  #llk = matrix(ncol=length(clusters),nrow=nrow(sum.patient.data), dimnames=list(sum.patient.data$Patient, clusters))

  llk = vector(length=length(clusters), mode='numeric')
  names(llk) = as.character(clusters)
  
## Ok, this doesn't separate regions well either normalized or raw segment values.  Typically the clusters are highly overlapped and not very descriptive
#for (pt in sum.patient.data$Patient) {
    print(pt)
#    status = subset(sum.patient.data, Patient == pt)$Status
#    print(ncol(patient.data[[pt]]$seg.vals[,-(1:5)]))
#    x1 = as.matrix(patient.data[[pt]]$seg.vals[,-(1:5)])
#    x1 = x1[,patient.data[[pt]]$info$Samplename]
    #x1 = as.matrix(patient.data[[pt]]$norm.seg.vals)
    
    for (g in clusters) {
      print(g)
      model = densityMclust(x1, G=g)
      highCluster = which.max(colSums(model$parameters$mean))
      
      tryCatch({
        mod1dr = MclustDR(model, lambda = 0.5)
        
        #     par(mfrow=c(2,1)) 
        plot(mod1dr, what="evalues")
        title(paste(pt, '(',status,') G=', g, sep=''))
        plot(mod1dr, what='classification') # while this looks like PCA, it's not quite
        title(paste(pt, '(',status,') G=', g, sep=''))
        #     dev.off()
        plot(mod1dr, what='density', dimens=1)
        title(paste(pt, '  G=', g, sep=''))
      }, error = function(e) {
        cat(paste(pt, g, "failed DR"))
      })
      
      a1 = rownames(x1[which(model$classification == highCluster),] )
      if (nrow(var.regions) > 0) {
        am = merge(a1, var.regions, all=T)
        pander( as.data.frame(rownames(x1[which(model$classification == highCluster),])),
             caption=paste("From the cluster with the highest means the regions above are selected, of these ",length(setdiff(rownames(var.regions), a1)),
                           " regions are not found in the variable regions selected using cutoffs.", length(intersect(rownames(var.regions), a1)), " are in both."))
      } else {
        pander(rownames(x1[which(model$classification == highCluster),]),
             caption=paste("From the cluster with the highest means the regions above are selected. This patient had no variable regions selected based on cutoffs"))
        
      }
      
      llk[as.character(g)] = model$loglik
    }
    return(llk)
}

llk = as.data.frame(matrix(nrow=nrow(sum.patient.data),ncol=3,dimnames=list(c(sum.patient.data$Patient), c(2:4))))
for (pt in sum.patient.data$Patient) {
    print(pt)
    status = subset(sum.patient.data, Patient == pt)$Status

    x1 = patient.data[[pt]]$seg.vals
    rownames(x1) = apply(x1, 1, function(x) strip.whitespace(paste(x[['chrom']], ':', x[['start.pos']], '-', x[['end.pos']], sep=''))) 
    x1 = x1[,patient.data[[pt]]$info$Samplename]

    var = patient.data[[pt]]$variable.regions
    if (nrow(var) > 0)
      rownames(var) = apply(var, 1, function(x) strip.whitespace(paste(x[['chrom']], ':', x[['start.pos']], '-', x[['end.pos']], sep=''))) 

    llk[pt,] =  em.dr(pt,status,as.matrix(x1), var[,-(1:5)])
  }

ggplot(melt(as.matrix(llk)), aes(x=Var1, y=value, color=Var1)) + geom_point() + 
  theme(axis.text.x=element_text(angle = 45), legend.position='none')
  labs(title="Raw segment value log liklihoods", x='', y='loglik')


# Log liklihood doesn't separate them individually or the range
llk.diff = apply(llk, 1, function(x) diff(range(x)) )
wilcox.test(llk.diff[subset(sum.patient.data, Status == 'NP')$Patient], llk.diff[subset(sum.patient.data, Status == 'P')$Patient])

#t.test(llk[subset(sum.patient.data, Status == 'NP')$Patient,'2'], llk[subset(sum.patient.data, Status == 'P')$Patient,'2'])
#t.test(llk[subset(sum.patient.data, Status == 'NP')$Patient,'3'], llk[subset(sum.patient.data, Status == 'P')$Patient,'3'])
#t.test(llk[subset(sum.patient.data, Status == 'NP')$Patient,'4'], llk[subset(sum.patient.data, Status == 'P')$Patient,'4'])
```

#### Kmeans
```{r kmeansraw, echo=F, message=F, warning=F, eval=F, fig.height=6, fig.width=6} 
## Kmeans
#   x1 = as.matrix(patient.data[[pt]]$seg.vals[,-(1:5)])
# 
for (pt in sum.patient.data$Patient) {
    print(pt)
    status = subset(sum.patient.data, Patient == pt)$Status
    x1 = patient.data[[pt]]$seg.vals
    rownames(x1) = apply(patient.data[[pt]]$seg.vals[,c(1:4)], 1, function(x) strip.whitespace(paste(x[['chrom']], ':', x[['start.pos']], '-', x[['end.pos']], sep=''))) 
    x1 = x1[,patient.data[[pt]]$info$Samplename]
    
    fit = kmeans(x1, 3)
    autoplot(fit, data=x1, label=T) + labs(title=paste(pt, '(', status, ') raw seg', sep=''))
    pander(patient.data[[pt]]$variable.regions[,(1:4)], caption='Variable regions selected by cutoffs')
}
```

### Normalized segmented values
```{r clust2, echo=T, message=T, warning=F, eval=T, fig.height=4, fig.width=4, eval=T}
llk = as.data.frame(matrix(nrow=nrow(sum.patient.data),ncol=3,dimnames=list(c(sum.patient.data$Patient), c(2:4))))
for (pt in sum.patient.data$Patient) {
    print(pt)
    status = subset(sum.patient.data, Patient == pt)$Status
    x1 = patient.data[[pt]]$norm.seg.vals
    rownames(x1) = apply(patient.data[[pt]]$seg.vals[,c(1:4)], 1, function(x) strip.whitespace(paste(x[['chrom']], ':', x[['start.pos']], '-', x[['end.pos']], sep=''))) 
    x1 = x1[,patient.data[[pt]]$info$Samplename]

    var = patient.data[[pt]]$variable.regions
    if (nrow(var) > 0)
      rownames(var) = apply(var, 1, function(x) strip.whitespace(paste(x[['chrom']], ':', x[['start.pos']], '-', x[['end.pos']], sep=''))) 
  
    llk[pt,] = em.dr(pt,status,x1, var)
  }

ggplot(melt(as.matrix(llk)), aes(x=Var1, y=value, color=Var1)) + geom_point() + 
  theme(axis.text.x=element_text(angle = 45), legend.position='none') + 
  labs(title="Normalized segment value log liklihoods", x='', y='loglik')

# Log liklihood doesn't separate them individually or the range
llk.diff = apply(llk, 1, function(x) diff(range(x)) )
wilcox.test(llk.diff[subset(sum.patient.data, Status == 'NP')$Patient], llk.diff[subset(sum.patient.data, Status == 'P')$Patient])

#t.test(llk[subset(sum.patient.data, Status == 'NP')$Patient,'2'], llk[subset(sum.patient.data, Status == 'P')$Patient,'2'])
#t.test(llk[subset(sum.patient.data, Status == 'NP')$Patient,'3'], llk[subset(sum.patient.data, Status == 'P')$Patient,'3'])
#t.test(llk[subset(sum.patient.data, Status == 'NP')$Patient,'4'], llk[subset(sum.patient.data, Status == 'P')$Patient,'4'])
```

#### Kmeans
```{r kmeansnorm, echo=F, message=F, warning=F, eval=F, fig.height=6, fig.width=6} 
for (pt in sum.patient.data$Patient) {
    print(pt)
    status = subset(sum.patient.data, Patient == pt)$Status
    x1 = patient.data[[pt]]$norm.seg.vals
    rownames(x1) = apply(patient.data[[pt]]$seg.vals[,c(1:4)], 1, function(x) strip.whitespace(paste(x[['chrom']], ':', x[['start.pos']], '-', x[['end.pos']], sep=''))) 
    x1 = x1[,patient.data[[pt]]$info$Samplename]
    
    fit = kmeans(x1, 3)
    print(autoplot(fit, data=x1, label=T) + labs(title=paste(pt, '(', status, ') normalized seg', sep='')))
    pander(patient.data[[pt]]$variable.regions[,(1:4)], caption='Variable regions selected by cutoffs')
}
```


```{r apclust-func, echo=F, message=F, warning=F}
suppressPackageStartupMessages( library(apcluster) )

apclust.data<-function(segdata, samples) {
  x1 = segdata[,intersect(colnames(segdata), samples)]
  x1 = x1[, samples]
  rownames(x1) = (segdata[,c(1:4)] %>%
    rowwise() %>%
    mutate(location=paste(paste(chrom, arm, sep=''), '.', start.pos, '-', end.pos, sep='')))$location
  return(x1)  
}

apclust<-function(segdata) {
  x1 = apclust.data(segdata)
  # q=0 minimize off-diagonal similarity
  ac = apcluster(negDistMat(r=2), x1, details=T, convits=25, q=0)
  return(list('apres'=ac, 'data'=x1))
}

net.similarity<-function(ac) {
  if (is.list(ac))
    ac = ac$apres
  ac@netsim
}

sum.similarity<-function(ac) {
  if (is.list(ac))
    ac = ac$apres
  ac@dpsim
}

clusters<-function(ac) {
  if (is.list(ac))
    ac = ac$apres
  ac@exemplars
}

plotAC<-function(aclist) {
  plot(aclist$apres, aclist$data)
} 

heatmapAC<-function(aclist) {
  heatmap(aclist$apres)
}

# First vs last samples
#x1 = apclust.data(patient.data[[pt]]$seg.vals[,c(1:4, 6, ncol(patient.data[[pt]]$seg.vals))], patient.data[[pt]]$info$Samplename)
```


```{r clustN, echo=T, message=T, warning=F, eval=F}
## Normalized Segmentation Values
#Doesn't work for the normalized values.  

for (pt in subset(sum.patient.data, Status == 'P')$Patient) {
  if (pt == 'AH0254') next
  print(pt)
  print(paste('norm.seg.vals cols:', ncol(patient.data[[pt]]$norm.seg.vals)))
  
  x1 = patient.data[[pt]]$norm.seg.vals
  model = Mclust(t(x1))
  print(paste('loglik', round(model$loglik,2)))
  
  tryCatch({
    mod1dr = MclustDR(model, lambda = 1)
    #summary(mod1dr)
    table(mod1dr$mixcomp)
  
    if (length(table(mod1dr$mixcomp)) > 1) {
      plot(mod1dr, what = "evalues")
      title(main=pt)
      #plot(mod1dr, what = "density")
    }
  })
}


```

## AP Clustering

So tried AP as that doesn't require the pre-definition for number of clusters.  It appears to give good separation, though there's a suggestion of two different types of progressors.

### Affinity Propagagion clustering described by Frey & Dueck, 2007

First on the raw segmentation values

```{r apclust, echo=T, message=T, warning=F, fig.height=10, fig.width=10, fig.align='left'}
q=0.2

sum.patient.data = arrange(sum.patient.data, Status)

## Using the segmentation values
sum.patient.data$years = with(sum.patient.data, paste(start.year, end.year, sep='-'))
sim = sum.patient.data[,c('Status','years')]
rownames(sim) = sum.patient.data[,'Patient']
for (pt in sum.patient.data$Patient) {
  patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, desc(Pathology))

  x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
  colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )

  ac = apcluster(negDistMat(x1, r=2), q=q, details=T, includeSim=T)
  
  last = ncol(x1)
  if (patient.data[[pt]]$info$Status[1] == 'P' & pt != 'AD0252')
    last = sort(grep('HGD|IMC', patient.data[[pt]]$info$Pathology), decreasing=T)[1]
  # if (ncol(x1) <= 15) {
  #   plot(ac, x1[,c(c(1:ncol(x1))[-last], last)], main=pt)
  # } else {
  #   plot(ac, x1[,c(1, sort(sample(c(1:(ncol(x1)-1))[c(-1,-last)], 8)) ,last) ], main=pt)
  # }

  sim[pt, 'ns'] = net.similarity(ac)
  sim[pt, 'ss'] = sum.similarity(ac)
  sim[pt, 'clusters'] = length(clusters(ac))
  sim[pt, 'max.sd'] = max(sapply(x1, sd))
  
  tmp = patient.data[[pt]]$variable.regions[,-(1:5)]
  sim[pt, 'n.var'] = nrow(patient.data[[pt]]$variable.regions[,-(1:5)])
  
  if (nrow(tmp) <= 0) {
    sim[pt,c('gains', 'loss')] = c(0,0)
  } else {
    sim[pt,'gains'] = length(tmp[tmp>=1.1])
    sim[pt,'loss'] =  length(tmp[tmp<=0.9])
  }
}
sim$id = rownames(sim)

# May be a difference
ttps = t.test( subset(sim, Status == 'NP')$ss, subset(sim, Status == 'P')$ss )$p.value
ttpn = t.test( subset(sim, Status == 'NP')$ns, subset(sim, Status == 'P')$ns )$p.value
ttpc = t.test( subset(sim, Status == 'NP')$clusters, subset(sim, Status == 'P')$clusters )$p.value

## Number of variable regions isn't so good, but maybe...
sim %>%
  group_by(Status) %>%
  summarise( mean = mean(n.var), sd = sd(n.var), med = median(n.var))
t.test( subset(sim, Status == 'NP')$n.var, subset(sim, Status == 'P')$n.var )$p.value

g1 = ggplot(sim[,c('Status','ss')], aes(y=ss, x=Status, fill=Status)) + geom_boxplot() + 
  geom_jitter(width=0.2) + stat_boxplot(geom ='errorbar') +
  labs(title=paste("p-value", signif(ttps, 3)), y='sum similarity')

g2 = ggplot(sim[,c('Status','clusters')], aes(y=clusters, x=Status, fill=Status)) + geom_boxplot() + 
  geom_jitter(width=0.2) + stat_boxplot(geom ='errorbar') +
  labs(title=paste("p-value", signif(ttpc, 3)), y='num. clusters')

grid.arrange(g1, g2, top='Raw seg values')

# fit = glm(Status~clusters, sim, family=binomial(link='logit'))
# pander(fit, justify='left')
# 
# sim = sim[, c('Status', 'clusters', 'ns','ss')]
# actualMatrix = matrix(0,1000,2,dimnames=list(c(), c('prec','recall')))
# for (i in 1:nrow(actualMatrix)) {
#   trainingRows = sample(1:nrow(sim), nrow(sim)-5)
#   train = sim[trainingRows,]
#   test = sim[-trainingRows,]
#   
#   fit = glm( (as.integer(Status)-1)~clusters, train, family=binomial(link='logit'))
#   pred = predict(fit, test, se.fit=F) # probabilities -- of which outcome though?
#   
#   actual = test$Status == 'P'
#   predicted = pred>0
#   
#   actualMatrix[i,'prec'] = getPrecision( actual, predicted )
#   actualMatrix[i, 'recall'] = getRecall( actual, predicted )
# }
# 
# ggplot(as.data.frame(actualMatrix), aes(x=recall, y=prec)) + geom_point() + 
#   geom_hline(yintercept = 0.5, col='red', alpha=0.5) +
#   labs(title='Precision/Recall for Progressor/NP prediction')

rc = cor.test(sim$max.sd, sim$clusters)
```

#### Cellularity?

We needed to check if cellularity was driving the difference in clusters. Overall that does not appear to be the case if we use the maximum standard deviation across all samples in a patient as a proxy: r=`r rc$estimate`, p-value=`r signif(rc$p.value, 2)`

### Are the clusters random?

```{r example_pt}
pt = 'PR1_HIN_042'
patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, desc(Pathology))

x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )

ac = apcluster(negDistMat(x1, r=2), q=q, details=T, includeSim=T)

cols = c('chr','cluster','P.x', 'x')
hgmx = matrix(nrow=0,ncol=length(cols),dimnames=list(c(), cols))
for (chr in c(1:22)) {
  for (i in 1:length(ac@clusters)) {
    cl = x1[ac@clusters[[i]],]  
    
    x = length(grep(paste('^',chr,'(p|q)',sep=''),  rownames(cl), value=T)) # n in cluster
    m = length(grep(paste('^',chr,'(p|q)',sep=''),  rownames(x1), value=T)) # total n
    n = nrow(x1)-m
    k = length(ac@clusters[[i]])

    hgmx = rbind(hgmx, cbind(chr, i, signif(dhyper(x,m,n,k),3), x))
  }
}

hgmx = as.data.frame(hgmx)

ggplot(subset(hgmx, x > 0), aes(x=chr,y=P.x,color=factor(cluster))) + ylim(0,1)+ 
  geom_point() + geom_line(alpha=0.1)

ggplot(subset(hgmx, x > 0 & cluster == 9), aes(x=factor(chr),y=P.x,fill=factor(cluster))) + ylim(0,0.5 )+ 
  geom_bar(colour='grey', stat='identity', position=position_dodge())


```

So what about using the normalized segmented values?

```{r apclustN, echo=T, message=T, warning=F, fig.height=8, fig.align='left'}
# Should this be performed on the normalized seg values instead?
sim3 = sum.patient.data[,c(2:4)]
rownames(sim3) = sum.patient.data[,1]
for (pt in sum.patient.data$Patient) {
  x1 = patient.data[[pt]]$norm.seg.vals
  ac = apcluster(negDistMat(x1, r=2), q=q, details=T, includeSim=T)
  #plot(ac)
  
  sim3[pt, 'ss'] = sum.similarity(ac)
  sim3[pt, 'ns'] = net.similarity(ac)
  sim3[pt, 'clusters'] = length(clusters(ac))
}

summarise(group_by(sim3, Status), mean.ns=mean(ns), sd.ns=sd(ns), mean.c=mean(clusters), sd.c=sd(clusters) )

# Doesn't show up here
ttp = t.test( subset(sim3, Status == 'NP')$ss, subset(sim3, Status == 'P')$ss )$p.value
#ttp = t.test( subset(sim3, Status == 'NP')$ns, subset(sim3, Status == 'P')$ns )$p.value
ttc = t.test( subset(sim3, Status == 'NP')$clusters, subset(sim3, Status == 'P')$clusters )$p.value

ggplot(sim3[,c('Status','ss')], aes(y=ss, x=Status, fill=Status)) + geom_boxplot() + geom_jitter(width=0.2) + 
  labs(title=paste("Norm seg values p-value", signif(ttp, 3)), y='sum similarity')
```

So using the raw segmentation values (not the normalized ones) try some leave one out xval to see if the currently weak differences still hold.

Patients first

```{r xval_pt, echo=T, warning=F, message=T, fig.align='left', fig.height=4, eval=F}
# Leave out patients
loo_xval = matrix(ncol=3, nrow=0, dimnames=list(c(), c('net.similarity', 'sum.similarity', 'clusters')))
for (i in 1:nrow(sum.patient.data)) {
  simL = sum.patient.data[-i,c(2:4)]
  rownames(simL) = sum.patient.data[-i,1]

  for (pt in sum.patient.data$Patient[-i]) {
    x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
    ac = apcluster(negDistMat(x1, r=2), q=q)
  
    simL[pt, 'ns'] = net.similarity(ac)
    simL[pt, 'ss'] = sum.similarity(ac)
    simL[pt, 'clusters'] = length(clusters(ac))
  }
  
  ttps = t.test( subset(simL, Status == 'NP')$ss, subset(simL, Status == 'P')$ss )$p.value
  ttpn = t.test( subset(simL, Status == 'NP')$ns, subset(simL, Status == 'P')$ns )$p.value
  ttc = t.test( subset(simL, Status == 'NP')$clusters, subset(simL, Status == 'P')$clusters )$p.value

  loo_xval = rbind(loo_xval, cbind(ttpn, ttps, ttc))
}

ggplot(melt(data.frame(loo_xval[,c(3)])), aes(x=variable, y=value, fill=variable)) +  
    geom_boxplot() + geom_jitter(shape=16, width=0.2) + geom_hline(yintercept=0.05, color='red', alpha=0.5) +
    stat_boxplot(geom ='errorbar') + labs(y='p-values', x='Iterations', title='Leave one (patient) out clustering') +
  scale_fill_manual(values=c('purple'), labels='clusters')
  

```

Then randomly leave out samples

```{r xval_smp, echo=F, warning=F, message=T, fig.align='left', fig.height=6, eval=F}

# Leave out samples?
looS_xval = matrix(ncol=3, nrow=0, dimnames=list(c(), c('net.similarity', 'sum.similarity', 'clusters')))
for (i in 1:20) { 
  simX = sum.patient.data[,c('Status','years')]
  rownames(simX) = sum.patient.data[,'Patient']

  for (pt in sum.patient.data$Patient) {
      x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename[-sample(1:(length(patient.data[[pt]]$info$Samplename)), 1)])
      ac = apcluster(negDistMat(x1, r=2), q=q)
  
      simX[pt, 'ns'] = net.similarity(ac)
      simX[pt, 'ss'] = sum.similarity(ac)
      simX[pt, 'clusters'] = length(clusters(ac))
    }
  
  ttpn = t.test( subset(simX, Status == 'NP')$ns, subset(simX, Status == 'P')$ns )$p.value
  ttps = t.test( subset(simX, Status == 'NP')$ss, subset(simX, Status == 'P')$ss )$p.value
  ttc = t.test( subset(simX, Status == 'NP')$clusters, subset(simX, Status == 'P')$clusters )$p.value

  looS_xval = rbind(looS_xval, cbind(ttpn,ttps, ttc))
}

ggplot(melt(data.frame(looS_xval[,c(3)])), aes(x=variable, y=value, fill=variable)) +  
    geom_boxplot() + geom_jitter(shape=16, position=position_jitter(0.2)) +
  geom_hline(yintercept=0.05, color='red', alpha=0.5) +
    stat_boxplot(geom ='errorbar') + labs(y='p-values', x='Iterations', title='Leave one (sample) out clustering') + 
    scale_fill_manual(values=c('#CC99FF'), labels='clusters')

```

## (xval) Re run clusters on the Progressors without the HGD sample
There is still a difference between the progressors and non, though the p-value does increase. Some of the progressors do start looking more like NPs in their similarity measure but not all of them.

```{r nofinal, echo=F, message=F, warning=F, fig.height=6, fig.width=10}

gain.threshold = 1.1
loss.threshold = 0.9

simX = sum.patient.data[,c('Status','years')]
rownames(simX) = sum.patient.data[,'Patient']
# Leave out final sample on the progressors 

for (pt in sum.patient.data$Patient) {
  print(pt)
  x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
  if (subset(sum.patient.data, Patient == pt)$Status == 'P' & length(which(grepl('HGD|IMC', patient.data[[pt]]$info$Pathology))) > 0) {
    final = grep('HGD|IMC', patient.data[[pt]]$info$Pathology)
    x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename[-final])
  }
  ac = apcluster(negDistMat(x1, r=2), q=q)
  
  simX[pt, 'ns'] = net.similarity(ac)
  simX[pt, 'ss'] = sum.similarity(ac)
  simX[pt, 'clusters'] = length(clusters(ac))
  
  simX[pt, 'n.var'] = nrow(patient.data[[pt]]$variable.regions[,-(1:5)])
}
  
ttpc = t.test( subset(simX, Status == 'NP')$clusters, subset(simX, Status == 'P')$clusters )$p.value
ggplot(melt(data.frame(simX[c('Status','clusters')])), aes(x=Status, y=value, fill=Status)) +  
    geom_boxplot() + geom_jitter(shape=16, position=position_jitter(0.2)) +
    stat_boxplot(geom ='errorbar') + labs(y='num. clusters', x='', title=paste('Leave out HGD sample(s) p-value', signif(ttpc, 3)))

t.test(subset(simX, Status == 'NP')$n.var, subset(simX, Status == 'P')$n.var)

#pander(subset(simX, Status == 'P' & ss <= mean(ss)), caption="These patients are still strongly in the Progressor group")

pander(subset(simX, Status == 'P' & clusters >= mean(clusters)), caption="These patients are more similar to Non-Progressors without their HGD sample(s)")

fit = glm(Status~clusters, simX, family=binomial(link='logit') )
summary(fit)

simX = simX[, c('Status', 'clusters', 'ns','ss','n.var')]
noHGDPR = as.data.frame(matrix(0,1000,2,dimnames=list(c(), c('prec','recall'))))
for (i in 1:nrow(actualMatrix)) {
  trainingRows = sample(1:nrow(simX), nrow(simX)-5)
  train = simX[trainingRows,]
  test = simX[-trainingRows,]
  
  fit = glm( Status~clusters, train, family=binomial(link='logit'))
  pred = predict(fit, test, se.fit=F) # probabilities -- of which outcome though?
  
  actual = test$Status == 'P'
  predicted = pred>0
  
  noHGDPR[i,'prec'] = getPrecision( actual, predicted )
  noHGDPR[i, 'recall'] = getRecall( actual, predicted )
}

#ggplot(as.data.frame(noHGDPR), aes(x=recall, y=prec)) + geom_point() + 
#  geom_hline(yintercept = 0.5, col='red', alpha=0.5) +
#  geom_vline(xintercept = 0.5, col='red', alpha=0.5) +
#  labs(title='Precision/Recall for Progressor/NP prediction NO HGD')

```

Currently, without the HGD/IMC samples we can predict progressors `r nrow(subset(noHGDPR, prec > 0.5))/nrow(noHGDPR)*100`% of the time.
In comparison, including HGD/IMC samples our predictions improve to `r length(which(actualMatrix[,'prec'] > 0.5))/nrow(actualMatrix)*100`%.

 
## And why q=0.2
```{r whyq, echo=F, message=F, warning=F}
sum.patient.data = arrange(sum.patient.data, Status)

pvals = as.data.frame(matrix(ncol=3,nrow=0,dimnames=list(c(), c('p.clusters','mean.clusters', 'sd.clusters'))))
status.clusters = list()
for (qv in seq(0,0.9,0.1)) {
  print(qv)
  
  ## Using the segmentation values
  simPC = sum.patient.data[,c(2:4)]
  rownames(simPC) = sum.patient.data[,1]
  for (pt in sum.patient.data$Patient) {
    patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, desc(Pathology))
  
    x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
    colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )
  
    ac = apcluster(negDistMat(x1, r=2), q=qv, convits=75)
    
    simPC[pt, 'ns'] = net.similarity(ac)
    #simPC[pt, 'ss'] = sum.similarity(ac)
    simPC[pt, 'clusters'] = length(clusters(ac))
  }
  
  # May be a difference
  #ttps = t.test( subset(simPC, Status == 'NP')$ss, subset(simPC, Status == 'P')$ss )$p.value
  ttpn = t.test( subset(simPC, Status == 'NP')$ns, subset(simPC, Status == 'P')$ns )$p.value
  ttpc = t.test( subset(simPC, Status == 'NP')$clusters, subset(simPC, Status == 'P')$clusters )$p.value

  pvals = rbind(pvals,cbind(ttpc, mean(simPC$clusters), sd(simPC$clusters)))
  
  by.clusters = simPC %>% group_by(Status) %>% summarise( n.mean.clusters=mean(clusters), n.sd.clusters=sd(clusters), se.clusters=sd(clusters)/sqrt(length(Status)) )
  
  status.clusters[[paste('q=',qv, sep='')]] = by.clusters
}
colnames(pvals) = c('p.clusters','mean.clusters', 'sd.clusters')
pvals$qv=seq(0,0.9,0.1)

clus = as.data.frame(do.call(rbind, lapply(status.clusters, function(x) c(x[['n.mean.clusters']], x[['n.sd.clusters']]  ))))
colnames(clus) = c('NP','P', 'NP.sd', 'P.sd')
clus$qv = seq(0,0.9,0.1)

m = melt(clus[,c(1:2,5)], measure.vars=c('NP','P'))
m[which(m$variable == 'NP'), 'sd'] = clus$NP.sd
m[which(m$variable == 'P'), 'sd'] = clus$P.sd

ggplot(m, aes(x=factor(qv), y=value, col=variable)) + geom_point() +
  geom_errorbar(aes(ymin=value-sd, ymax=value+sd), width=.02) +
  geom_hline(yintercept=5, alpha=0.3) + 
  geom_hline(yintercept=15, alpha=0.3, col='red') + 
  scale_y_continuous(breaks=seq(0,max(m$value)+5, 10),labels=seq(0,max(m$value)+5, 10)  ) +
  labs(title='Clusters vs q parameters', x='q parameter', y='mean(clusters)') 

pander(clus[,c('qv','NP','P')], caption="Mean of clusters by patient status per q parameter.")

ggplot(melt(pvals, measure.vars=c('p.clusters'), id.vars='qv'),aes(x=factor(qv),y=value, color=variable)) + 
  geom_point() + 
  labs(title='P vs NP p-values per q parameters', y='pvalue NP vs P', x='q param')
  

```


```{r loc_pca, echo=F, warning=F, message=T, fig.height=12, fig.width=20, eval=F}
## Can we identify regions in the progressors?

#Not really just from the SVDs.  This isn't any different at the moment from simply calling the variable regions directly.

count.occurrences<-function(grs) {
  ov = findOverlaps(grs, type="within", ignoreSelf=TRUE,select="arbitrary")
  counts = countOverlaps(grs, type='within', maxgap=0)

  newgrs = grs[is.na(ov)]
  
  newgrs$overlaps = 0
  newgrs$patients = ''

  patients = c()  
  index = 1
  occurence = vector(mode='numeric')
  for (x in which(is.na(ov))) {
    occurence = c(occurence, sum(count[index:x]))
    patients = c(patients, paste(grs[index:x]$patient, collapse=','))
    index = x+1
  }
  newgrs$overlaps = occurence
  newgrs$patients = patients

  newgrs$patient.count = unlist(lapply(strsplit(patients, ','), length))
  
  newgrs$patient = NULL  
  return(newgrs)
}
annotate.cosmic<-function(grs) {
  ccgenes = read.table('~/Data/CosmicCensusGenes.tsv', sep='\t', header=T, stringsAsFactors=F)
  ensembl = biomaRt::useMart("ENSEMBL_MART_ENSEMBL", host="grch37.ensembl.org")
  mart = useDataset("hsapiens_gene_ensembl", ensembl)
  
  grs$Genes = 0
  grs$Cosmic.count = 0
  grs$Cosmic.genes = ''
  
  plocs = as.data.frame(grs)  
  for (i in 1:nrow(plocs)) {
    bm = getBM(mart = mart,
        attributes=c('hgnc_symbol', 'entrezgene' ), filters = c('chromosome_name', 'start', 'end' ),
        values = with(plocs[i,], list(gsub("chr", "", as.character(seqnames)), start, end)))

    grs[i]$Genes = length(unique(bm$hgnc_symbol))
    grs[i]$Cosmic.count = length(intersect(bm$entrezgene, ccgenes$Entrez.GeneId))
    grs[i]$Cosmic.genes = paste(intersect(bm$hgnc_symbol, ccgenes$Gene.Symbol), collapse=',')
  }

  return(grs)
}

#pt = 'PR1_HIN_042'
gg.svd<-function(mat, names, sd=0, n=3) {
  df = as.data.frame(mat[,(1:n)])
  
  for (i in 1:ncol(df)) {
    high = mat[,i] > (mean(mat[,i]) + sd * sd(mat[,i]))
    low = mat[,i] < (mean(mat[,i]) - sd * sd(mat[,i]))
  
    label = high | low
    color=label
  
    for (j in 1:length(label))
      label[j] = ifelse(label[j], names[j], '')
  
    df = cbind(df, label, color)
    colnames(df)[grep('^label$', colnames(df))] = paste('SV',i,'.label',sep='')
    colnames(df)[grep('^color$', colnames(df))] = paste('SV',i,'.color',sep='')
  }
  df$x = 1:nrow(df)
  return(df)
  }

pt.regions = list()
for (pt in sum.patient.data$Patient) {
  print(pt)
  patient.data[[pt]]$info = arrange(patient.data[[pt]]$info, Endoscopy.Year, Pathology)

  x1 = apclust.data(patient.data[[pt]]$seg.vals, patient.data[[pt]]$info$Samplename)
  colnames(x1) = paste(patient.data[[pt]]$info$Endoscopy.Year, '(', patient.data[[pt]]$info$Pathology, ')', sep='' )

  #plot.pca(pt)
  #pca = prcomp(t(x1), center=T)
  
  #plot(pca$sdev^2, type='o')
  
  svd = svd(t(x1))
  colnames(svd$u) = paste('SV',1:ncol(svd$u), sep='') 
  colnames(svd$v) = paste('SV',1:ncol(svd$v), sep='') 

  #plot(svd$d, type='o', main='Scree')
  # u matrix
  samples = gg.svd(svd$u, colnames(x1), 0, 3)
  grid.arrange(
    ggplot(samples, aes(y=SV1, x=x, col=SV1.color)) + geom_point() +
      geom_text(aes(label=SV1.label), vjust=0) + guides(color='none'),
    ggplot(samples, aes(y=SV2, x=x, col=SV2.color)) + geom_point() +
      geom_text(aes(label=SV2.label), vjust=0) + guides(color='none'),
    ggplot(samples, aes(y=SV3, x=x, col=SV3.color)) + geom_point() +
      geom_text(aes(label=SV3.label), vjust=0) + guides(color='none'),
    top='SVD Samples')
  
  # v matrix
  regions = gg.svd(svd$v, rownames(x1), 2, 3)
  grid.arrange(
    ggplot(regions, aes(y=SV1, x=x, col=SV1.color)) + geom_point() +
      geom_text(aes(label=SV1.label), vjust=0) + guides(color='none'),
    ggplot(regions, aes(y=SV2, x=x, col=SV2.color)) + geom_point() +
      geom_text(aes(label=SV2.label), vjust=0) + guides(color='none'),
    ggplot(regions, aes(y=SV3, x=x, col=SV3.color)) + geom_point() +
      geom_text(aes(label=SV3.label), vjust=0) + guides(color='none'), 
    top='SVD Locations')
  
  locs = as.character(unlist(c(regions[grep('SV1.label',colnames(regions))])))
  locs = unique(locs[grep("\\w+", locs)])


  high = names(which(apply(x1[locs,], 1, function(x) length(which(x >= 1.1))) > 0))
  low = names(which(apply(x1[locs,], 1, function(x) length(which(x <= 0.9))) > 0))

  hls = as.data.frame(do.call(rbind, strsplit(c(high, low), '[p|q]\\.|-')))
  colnames(hls) = c('chr','start','stop')
  hls[c('start','stop')] = lapply(hls[c('start','stop')], function(x) as.numeric(as.character(x))) 
  
  #ac = apcluster(negDistMat(x1, r=2), q=0.2)

  #lapply(ac@clusters, function(x) names(x)[which(names(x) %in% high)])
  #lapply(ac@clusters, function(x) names(x)[which(names(x) %in% low)])

  pt.regions[[pt]] = data.frame(hls, cn=c(rep('gain', length(high)), rep('loss',length(low))))
}
pt.regions = do.call(rbind, pt.regions)

pt.regions$patient = sub('\\..*', '', rownames(pt.regions) )
rownames(pt.regions) = 1:nrow(pt.regions)

prog.grs = sort(makeGRangesFromDataFrame(subset(pt.regions, patient %in% subset(sum.patient.data, Status == 'P')$Patient), keep.extra.columns = T, seqnames.field = 'chr', seqinfo=c(1:22,'X','Y')))

np.grs = sort(makeGRangesFromDataFrame(subset(pt.regions, patient %in% subset(sum.patient.data, Status == 'NP')$Patient), keep.extra.columns = T, seqnames.field = 'chr', seqinfo=c(1:22,'X','Y')))


prog.loss = count.occurrences(subset(prog.grs, grepl('loss',cn)))
prog.gain = count.occurrences(subset(prog.grs, grepl('gain',cn)))

np.loss = count.occurrences(subset(np.grs, grepl('loss',cn)))
np.gain = count.occurrences(subset(np.grs, grepl('gain',cn)))


pg.c = annotate.cosmic(prog.gain)
pl.c = annotate.cosmic(prog.loss)

npg.c = annotate.cosmic(np.gain)
npl.c = annotate.cosmic(np.loss)


with(pg.c,plot(overlaps, Cosmic.count, col='blue', pch=19))
with(pl.c, points(overlaps, Cosmic.count, col='red', pch=19))

with(npg.c, points(overlaps, Cosmic.count, col='green', pch=18))
with(npl.c, points(overlaps, Cosmic.count, col='purple', pch=17))

pander(data.frame('total.p' = sum(length(pg.c), length(pl.c)), 'total.np' = sum(length(npg.c), length(npl.c))), caption="Total regions called as gains/losses for progressors vs non")

t.test( width(pg.c), width(npg.c) ) # Yes for the gains
t.test( width(pl.c), width(npl.c) ) # Not for the losses

```


```{r model, echo=F, warning=F, message=F, fig.height=12, fig.width=20, eval=F}

t.test(subset(sim, Status == 'P')$clusters, subset(sim, Status == 'NP')$clusters)

t.test(subset(simX, Status == 'P')$clusters, subset(simX, Status == 'NP')$clusters)


## TODO  Need to consider segment lengths relative to chromosomal lengths

var.lengths = as.data.frame( do.call(rbind, lapply(patient.data, function(x){
  if (nrow(x[['variable.regions']]) > 0) {
    lengths = as.vector( (x[['variable.regions']]['end.pos'] - x[['variable.regions']]['start.pos'])[,1] )
    return(c(median(lengths), mean(lengths), sd(lengths), sd(lengths)/length(lengths)))
  }
  return(NA)
})) )
colnames(var.lengths) = c('median','mean','sd','se')

var.lengths = merge(sum.patient.data, var.lengths, by.x='Patient', by.y='row.names')


var.lengths
wilcox.test(subset(var.lengths, Status == 'P')$mean, subset(var.lengths, Status == 'NP')$mean)



```
