---
title: "Scoring Patients"
author: "Sarah Killcoyne"
date: "15 November 2016"
output:
  html_document: 
    toc: yes
  word_document: default
---


```{r setup, include=FALSE}
library(ggplot2)
library(GGally)
library(plyr)
library(xlsx)
library(dplyr)
library(pander)
library(Hmisc)
library(ggdendro)
library(reshape2)
library(GenomicRanges)
library(gridExtra)
library(tibble)

source('lib/load_patient_metadata.R')

data = '~/Data/Ellie'

data.files = list.files(paste(data, 'QDNAseq',sep='/'), full.names=T)
plot.dir = paste(data, 'Analysis/multipcf_plots_fitted_perPatient', sep='/')

if (length(list.files(plot.dir)) <= 0)
  stop(paste("No analysis files found in", plot.dir ))

## Patient info file
patient.file = grep('All_patient_info.xls', data.files, value=T)
if (length(patient.file) != 1)
  stop(paste("Missing/too many patient info file(s) in", data))

patient.info = read.patient.info(patient.file)
patient.info$Patient = gsub("/", "_", patient.info$Patient)
head(patient.info)

patient.info = arrange(patient.info, Status, Patient, Endoscopy.Year, Pathology)

sum.patient.data = summarise.patient.info(patient.info)

#patient.info = subset(patient.info, Patient %in% sum.patient.data$Patient & Batch.Name %in% levels(patient.info$Batch.Name)[1:5])

#pander(arrange(patient.data, Status), justify='left', caption='Patient information')
```

```{r cors, echo=F, message=T, warning=F, fig.height=6, fig.width=6, fig.align='left', include=F}
## Cluster the samples by coverage then pull out regions

## Thresholds
min.probes=67 # equiv to 1MB
gamma2 = 250
sd.threshold = 0.08  # cov by numbers of probes

gain.threshold = 1.1
loss.threshold = 0.9

patient.data = list()

for (patient.name in unique(patient.info$Patient)  )  {
  message(patient.name)
  patient.plot.dir = paste(plot.dir, patient.name, sep='/')

  if(!file.exists(paste(patient.plot.dir, "/",patient.name,"_segmentedCoverage_fitted_gamma",gamma2,".txt",sep=""))) next
  
  segvals = read.table(paste(patient.plot.dir, "/",patient.name,"_segmentedCoverage_fitted_gamma",gamma2,".txt",sep=""),sep="\t",stringsAsFactors=F,header=T)

  missing = c(setdiff(colnames(segvals)[-(1:5)], subset(patient.info, Patient == patient.name)$Samplename),
                    setdiff(subset(patient.info, Patient == patient.name)$Samplename, colnames(segvals)[-(1:5)]))
  
  if (length(missing) > 0) 
    warning(paste("Missing", length(missing), "sample(s) in patient", patient.name))
  
  message( paste(length(which(segvals$n.probes < min.probes)), ' probes below the minimum probe count (',min.probes,')', sep=''))
  
  segvals = segvals[segvals$n.probes>=min.probes,]

  # ORDER segvals by endoscopy year etc
  cur.pt = subset(patient.info, Patient == patient.name)
  segvals = segvals[, c(colnames(segvals[1:5]), intersect(colnames(segvals), cur.pt$Samplename))]
    
  patient.data[[patient.name]][['seg.vals']] = segvals
  patient.data[[patient.name]][['info']] = cur.pt

  if(nrow(segvals)>0) {
      HC = hclust(dist(t(segvals[,-(1:5)])))
      gg1 = ggdendrogram(HC, rotate=T) + labs(title = paste(patient.name,": fitted segment coverage"),x="")
      #print(gg1)

      # Normalize  (value-mean(value))/sd(value)
      normalised.segvals = segvals[,-(1:5)]
      for(c in 1:nrow(normalised.segvals)) {
        normalised.segvals[c,] = (normalised.segvals[c,]-mean(unlist(normalised.segvals[c,])))/sd(unlist(normalised.segvals[c,]))
      }
      patient.data[[patient.name]][['norm.seg.vals']] = normalised.segvals
      
      # Variable Regions
      sds = apply(segvals[,-(1:5)],1,sd)
      means = apply(segvals[,-(1:5)],1,mean)
      CofV = sds/means
  
      variable.region.indices = which(sds >= sd.threshold & segvals$n.probes >= min.probes)
      variable.regions = segvals[variable.region.indices, intersect(patient.data[[patient.name]]$info$Samplename, colnames(segvals))] 
      patient.data[[patient.name]][['variable.regions']] = cbind(segvals[variable.region.indices,c(1:5)],variable.regions )
      
      HC = hclust(dist(t(normalised.segvals)))
      gg2 = ggdendrogram(HC, rotate=T) + labs(title=paste(patient.name,": normalised fitted segment coverage", x=""))
      #print(gg2)

      no.samples = ncol(normalised.segvals)
      no.rows = ceiling(no.samples/3)

      gg3 = ggplot( melt(normalised.segvals), aes(x=value) ) + 
        facet_wrap(~variable,scales = "free_x") + 
        geom_histogram( fill=I("blue"),col=I("lightblue"),binwidth=0.3) + labs(title=paste(patient.name,'normalised segment coverage'), x='', y='')
     # print(gg3)
      #pt.plots[[patient.name]][['norm.hist']] = gg
      
      # par(mfrow=c(3, no.rows))
      # for(s in 1:no.samples) 
      #   hist(normalised.segvals[,s],col="blue",main=names(normalised.segvals)[s],xlab="normalised coverage")

      if(nrow(segvals)>=3) {
        # order by date of endoscopy
        patient = subset(patient.info, Patient == patient.name)
        patient = arrange(patient, Endoscopy.Year, Pathology, Samplename)
        }
        sample.normalised.segvals = normalised.segvals[, intersect(colnames(normalised.segvals), patient$Samplename)]
      }
}

sum.patient.data = subset(sum.patient.data, Patient %in% names(patient.data))


## Check that all of the samples are there
patient.info = arrange(patient.info, Status, Patient, Endoscopy.Year,Samplename)
pt = 'AH0254'
info = subset(patient.info, Patient == 'AH0254')
lapply(names(patient.data), function(pt) {
  missing = which(!patient.data[[pt]]$info$Samplename %in% colnames(patient.data[[pt]]$seg.vals))
  if (length(missing) > 0) {
    msg = paste(pt,": Missing samples - ", paste(patient.data[[pt]]$info$Samplename[missing], collapse=', ') , sep='')
    msg = paste(msg, "\nFrom batch: ", paste(unique(patient.data[[pt]]$info$Batch.Name[missing]), collapse=', '))
    warning(msg)
  }
})


save(patient.data, file='patients.Rdata')


## Note the number of probes per patient/sample
```
\pagebreak

# Data

This data was generated in the following pipeline:

* Alignment using QDNAseq
* Filter excluded regions
* Joint segmentation per patient across all patient-derived-samples using PCF  (copynumber::multipcf method)

The result looks like two data matrices:

1. Segmented values 
```{r}
head(patient.data[['AD0258']]$seg.vals)
```

```{r echo=F, warning=F, message=F, fig.height=10, fig.width=10}
ggplot( melt(patient.data[['AD0258']]$seg.vals[,-(1:5)]), aes(x=value) ) + 
        facet_wrap(~variable,scales = "free_x") + 
        geom_histogram( fill=I("blue"),col=I("lightblue"), binwidth=0.03) + labs(title='AD0258 segmented value distribution', x='', y='')
```

2. Row (e.g. per-region across timepoints) normalized values from the matrix above
```{r}
head(patient.data[['AD0258']]$norm.seg.vals)
```

```{r echo=F, warning=F, message=F, fig.height=10, fig.width=10}
ggplot( melt(patient.data[['AD0258']]$norm.seg.vals), aes(x=value) ) + 
        facet_wrap(~variable,scales = "free_x") + 
        geom_histogram( fill=I("blue"),col=I("lightblue"), binwidth=0.3) + labs(title='AD0258 normalized segmented value distribution', x='', y='')

## Per-sample normalization
#nsv = patient.data[['AD0258']]$norm.seg.vals
#nsv[] = lapply(patient.data[['AD0258']]$seg.vals[,-(1:5)], function(x) (x-mean(x))/sd(x))

#ggplot(melt(nsv), aes(x=value))  + 
#        facet_wrap(~variable,scales = "free_x") + 
#        geom_histogram( fill=I("blue"),col=I("lightblue"), binwidth=0.3) + labs(title='AD0258 normalized segmented value distribution', x='', y='')

```

Patients do not share the same chromosomal regions, though they can be overlapped, or the same timepoints. So all analyses have been conducted on a per-patient basis.

```{r general, warning=F, echo=F, message=F}
gen = do.call(rbind, lapply(patient.data, function(df) {
  cbind('n.segments'=nrow(df[['seg.vals']]), 
        'median.seg.len'=median(df$seg.vals[,c('end.pos')] - df$seg.vals[,c('start.pos')]),
        'mean.seg.len'=mean(df$seg.vals[,c('end.pos')] - df$seg.vals[,c('start.pos')]), 
        'sd.seg.len'=sd(df$seg.vals[,c('end.pos')] - df$seg.vals[,c('start.pos')]))
}))
rownames(gen)  = names(patient.data)

sum.patient.data = merge(sum.patient.data, gen, by.x='Patient', by.y='row.names')
sum.patient.data = arrange(sum.patient.data, Status, total.samples)
sum.patient.data$years = with(sum.patient.data, paste(start.year, end.year, sep='-'))

pander(sum.patient.data[,c('Patient','Status','years','total.samples','highest.path','n.segments', 'median.seg.len')], justify='left')



#seg.lens = lapply(patient.data, function(df) df$seg.vals[,c('end.pos')] - df$seg.vals[,c('start.pos')] )


#wilcox.test(log(unlist(seg.lens[subset(sum.patient.data, Status == 'P')$Patient])),
#log(unlist(seg.lens[subset(sum.patient.data, Status == 'NP')$Patient])))

#hist(log(unlist(seg.lens[subset(sum.patient.data, Status == 'P')$Patient])))
#hist(log(unlist(seg.lens[subset(sum.patient.data, Status == 'NP')$Patient])))


ggplot(sum.patient.data) + geom_boxplot( aes(y=median.seg.len, x=Status, group=Status, fill=Status) ) +
  labs(title="Median segment length by patient status")


```

There's no significant difference between the length of segments in progressors vs non.  There's a larger spread of lengths in progressors, but the means are nearly identical.


# Segmented Value Distributions
```{r echo=F, message=F, warning=F, fig.height=15, fig.width=10, eval=F}

lapply(patient.data, function(pt) {
  name = pt$info$Patient[1]
  status = pt$info$Status[1]
  
  g1 = ggplot( melt(pt[['seg.vals']][,-(1:5)]), aes(x=value) ) + 
      facet_wrap(~variable,scales = "free_x") + 
      geom_histogram( fill=I("blue"),col=I("lightblue"), binwidth=0.03) + 
      labs(title='segmented value distribution', x='', y='')

  
  g2 = ggplot( melt(pt[['norm.seg.vals']]), aes(x=value) ) + 
      facet_wrap(~variable,scales = "free_x") + 
      geom_histogram( fill=I("blue"),col=I("lightblue"), binwidth=0.3) + 
      labs(title='normalized segmented value distribution', x='', y='')

  do.call('grid.arrange', list(g1,g2, top=paste(name, status, sep=" - ")))
})

```

# Variable Regions

These are regions that are called as "variant" based on cutoffs derived from a single sample that had high-depth (50x) WGS done and was then downsampled. These cutoffs are:

* Standard deviation of the segmented value matrix >= 0.08
* The number of probes used >= 67, covers 1Mb 
* Gains are called at >= 1.1
* Losses are called at <= 0.9


```{r var_reg, echo=F, message=F, warning=F}
prog.pt = subset(sum.patient.data, Status == 'P')$Patient
np.pt = subset(sum.patient.data, Status == 'NP')$Patient

var.seg.lengths = lapply(patient.data, function(df) {
  cbind('chr'=df$variable.regions$chrom, 'seg.len'=df$variable.regions$end.pos - df$variable.regions$start.pos)
})

segment.lengths = lapply(patient.data, function(df) {
  cbind('chr'=df$seg.vals$chrom, 'seg.len'=df$seg.vals$end.pos - df$seg.vals$start.pos)
})


prog.regions = sapply(var.seg.lengths[sum.patient.data$Patient], nrow)

sum.patient.data$Num.Var.Regions = as.vector(sapply(var.seg.lengths[sum.patient.data$Patient], nrow))

chrs = read.table('hg19_chrom.txt',sep='\t', header=T)
var.seg.lengths = lapply(var.seg.lengths, function(x) merge(x, chrs, by.x='chr', by.y='chr') )

segment.lengths= lapply(segment.lengths, function(x) merge(x, chrs, by.x='chr', by.y='chr') )

opcov = sapply(segment.lengths[prog.pt], function(x) {
  sum(as.numeric(x[['seg.len']]))/sum(as.numeric(chrs$length))
})

onpcov = sapply(segment.lengths[np.pt], function(x) {
  sum(as.numeric(x[['seg.len']]))/sum(as.numeric(chrs$length))
})

chr.ratios = lapply(var.seg.lengths, function(x) x[['seg.len']]/x[['length']])
# Segment coverage, variable regions
ttR = t.test(unlist(chr.ratios[subset(sum.patient.data, Status == 'P')$Patient]), 
             unlist(chr.ratios[subset(sum.patient.data, Status == 'NP')$Patient]))

var.seg.lengths = lapply(var.seg.lengths, function(df) {
  as.data.frame(df %>%
  group_by(chr, length) %>%
  summarise(seg.lengths = sum(seg.len), 
            chr.ratio = sum(seg.len)/length[1]))
})

pcov = median(sapply(var.seg.lengths[prog.pt], function(x) 
  sum(as.numeric(x[['seg.lengths']]))/sum(as.numeric(x[['length']])) ), na.rm=T)

npcov = median(sapply(var.seg.lengths[np.pt], function(x) 
  sum(as.numeric(x[['seg.lengths']]))/sum(as.numeric(x[['length']])) ), na.rm=T)


## Grouping the chromosomes by length 1-12, 13-22
#t.test(subset(np.regions, chrom %in% c(1:12))$chr.ratio, subset(np.regions, chrom %in% c(13:22))$chr.ratio)

#t.test(subset(prog.regions, chrom %in% c(1:12))$chr.ratio, subset(prog.regions, chrom %in% c(13:22))$chr.ratio)


#There may be an enrichment for segments in the shorter chromosomes amongst progressors but it's weak (fisher `r ftL$p.value`)
#df = data.frame( 'short' = rbind( 'np' = sum(table(np.regions$chrom)[1:12]),
#       'p' = sum(table(prog.regions$chrom)[1:12])),
#                 'long' = rbind( 'np' = sum(table(np.regions$chrom)[13:22], na.rm=T),
#       'p' = sum(table(prog.regions$chrom)[13:22], na.rm=T)))

#ftL = fisher.test(df)
```


So it appears that adjusting for chromosome length (looking at the ratio of the chromosome covered by segments rather than the raw bp) a significant difference in the coverage of the genome by CN segments that are variable between progressors and non: t-test p-value `r signif(ttR$p.value, 2)`.  Overall bp coverage of the sWGS is `r round(mean(c(opcov, onpcov)), 2)*100`%  (P `r round(mean(opcov),2)`, NP `r round(mean(onpcov), 2)`).  

Variable regions cover `r round(pcov, 2)*100`% of the the progressors genome, and `r round(npcov, 2)*100`% of non-progressor genomes.

```{r cor, echo=F, message=F, warning=F, fig.height=10,fig.width=10, fig.align='left', eval=F}

lower<-function(rc) {
 ut = upper.tri( rc$r , diag=T) 
 rc$r[ut] = 0
 rc$P[ut] = NA
 return(rc)
}

sig.rc<-function(rc) {
  sig = rc$P > 0.05
  rc$r[sig] = 0
  return(rc)
}


cors = list()
for (name in names(patient.data)) {
  sample.normalised.segvals = patient.data[[name]]$norm.seg.vals # prog
  sample.normalised.segvals =  sample.normalised.segvals[, intersect(patient.data[[name]]$info$Samplename, colnames(sample.normalised.segvals)) ]
  
  info = subset(patient.data[[name]]$info, Samplename %in% colnames(sample.normalised.segvals))
  
  colnames(sample.normalised.segvals) =  paste(info$Endoscopy.Year,  c(1:nrow(info)) , sep='.')

  #sample.normalised.segvals = patient.data$AD0361$norm.seg.vals # non-p
  rc = rcorr(as.matrix(sample.normalised.segvals), type='pearson')
  #rc = sig.rc(lower(rc))
  rc = sig.rc(rc)

  diff = unlist(apply(rc$r, 1, function(x)  sum(x[x < 0])-1 ))/nrow(rc$r)
  sim = unlist(apply(rc$r, 1, function(x)  sum(x[x > 0])-1 ))/nrow(rc$r)

  t.test(abs(sim), abs(diff))

  cors[[name]][['sim']] = sim
  cors[[name]][['diff']] = diff
}

unlist(lapply(cors, function(x) t.test(abs(x$sim), abs(x$diff))$p.value))

simPNP = wilcox.test(unlist(lapply(cors[subset(sum.patient.data, Status == 'P')$Patient], function(x) sum(x$sim))),
            unlist(lapply(cors[subset(sum.patient.data, Status == 'NP')$Patient], function(x) sum(x$sim))))

diffPNP = wilcox.test(unlist(lapply(cors[subset(sum.patient.data, Status == 'P')$Patient], function(x) sum(x$diff))),
            unlist(lapply(cors[subset(sum.patient.data, Status == 'NP')$Patient], function(x) sum(x$diff))))

#There's no clear difference (currently) between P and NP for the similar correlation (`r simPNP$p.value`) or the inverse (`r diffPNP$p.value`) correlations.  There are other ways we may be able to look at this still.

```


## How do Cancer Gene Consensus genes map to the variable regions?

```{r, hmm, echo=F, message=F, warning=F, fig.height=40, fig.width=10}
ccgenes = read.table('~/Data/CosmicCensusGenes.tsv', sep='\t', header=T, stringsAsFactors=F)

noLoc = grep(':-',ccgenes$Genome.Location)
noLocGenes = ccgenes[noLoc,]

ccgenes = ccgenes[-noLoc,]

locs = as.data.frame(do.call(rbind, strsplit(ccgenes$Genome.Location, ':|-')))
colnames(locs) = c('chr','start','end')
locs[c('start','end')] = lapply(locs[c('start','end')], function(x) as.numeric(as.character(x)))

ccgenes = cbind(locs, ccgenes)
ccgenes = makeGRangesFromDataFrame(ccgenes, keep.extra.columns = T, start.field = 'start', end.field = 'end')

# ov = findOverlaps(ccgenes, ccgenes)
# ov = ov[queryHits(ov) != subjectHits(ov)]
# ccgenes = ccgenes[-subjectHits(ov)[1]]

cancer.consensus.genes<-function(reg, ccgenes) {
  reg = as_tibble(reg)
  gr = GenomicRanges::makeGRangesFromDataFrame(reg, start.field = 'start.pos', end.field = 'end.pos')

  ov = findOverlaps(ccgenes, gr)
  reg$Gene.Symbols = NA
  for (hit in unique(subjectHits(ov))) {
    reg[hit, 'Gene.Symbols'] =  paste(ccgenes[queryHits(ov)[which(subjectHits(ov) == hit)],]$Gene.Symbol, collapse=',')
  }
  
  rwg = cbind(reg, reg[,-(1:5)])
  return(rwg)
}

rm(var.regions)
for (patient.name in names(patient.data)) {
  regions = patient.data[[patient.name]]$variable.regions[,c('chrom','arm','start.pos','end.pos')]
  if (nrow(regions) <= 0) next

  reg = cancer.consensus.genes(regions, ccgenes)
  x = patient.data[[patient.name]]$variable.regions[which(!is.na(reg$Gene.Symbols)), intersect(patient.data[[patient.name]]$info$Samplename, colnames(patient.data[[patient.name]]$variable.regions))  ]

  gl = apply(x, 1, function(y)  ifelse(length(which(y >= 1.1)) > length(which(y <= 0.9)), 'gain', 'loss') )
  reg[which(!is.na(reg$Gene.Symbols)), 'CN'] = gl
  reg = reg[,c('chrom','arm','start.pos','end.pos','CN','Gene.Symbols')]

  for (i in 1:nrow(reg)) {
    if (is.na(reg[i,'Gene.Symbols'])) next
    genes = unlist(strsplit(reg[i,'Gene.Symbols'], ','))
    
    reg[i,'Gene.Symbols'] = genes[1]
    
    if (length(genes) > 1)
      reg = rbind(reg, cbind(reg[i, (1:5)], 'Gene.Symbols' = genes[2:length(genes)]))
  }
  reg = arrange(reg, chrom, arm, start.pos)
  
  status = subset(sum.patient.data, Patient == patient.name)$Status
  
  reg = cbind(patient.name, status, reg)
    
  if (!exists('var.regions')) {
    var.regions = reg
  } else {
    var.regions = rbind(var.regions, reg)
  }
}

var.regions = var.regions[!is.na(var.regions$Gene.Symbols),]
var.regions$patient.name = as.character(var.regions$patient.name)

var.regions = var.regions[-grep('CDKN2A\\(p14\\)', var.regions$Gene.Symbols),]

gene.cnt = var.regions %>%
  group_by(Gene.Symbols, CN) %>%
  summarise(Progressors=length(which(status == 'P')), Non.Progressors=length(which(status == 'NP')) )
gene.cnt[,unique(var.regions$patient.name)] = 0
gene.cnt = gene.cnt[which(!is.na(gene.cnt$Gene.Symbols)),]

for (i in 1:nrow(gene.cnt)) {
  gene = as.character(gene.cnt[i,'Gene.Symbols'])
  type = as.character(gene.cnt[i,'CN'])
#  print(paste(gene, type))
#  print(subset(var.regions, Gene.Symbols == gene & CN == type)$patient.name)
  gene.cnt[i,unique(subset(var.regions, Gene.Symbols == gene & CN == type)$patient.name)] = 1
}

gene.cnt = arrange(gene.cnt, -Progressors)
gene.p = subset(gene.cnt, Progressors >= Non.Progressors)

m = melt(gene.p[,c(1:4)], id.vars=c('Gene.Symbols', 'CN'))
m$Gene.Symbols = factor(m$Gene.Symbols, levels= m$Gene.Symbols[c(nrow(m):1)] ) # order
m$CN = factor(m$CN)
 
p = ggplot(m, aes(y=Gene.Symbols, x=variable)) + 
  geom_tile(aes(fill=value), color='white') + 
  scale_fill_gradient('n patients',low='white',high='royalblue4') + labs(x="",y='CGC Genes')
p + geom_point(data=m[m$CN == 'gain' & m$value > 0,], aes(y=Gene.Symbols, x=variable), size=2, shape=24, fill='red', color='red') +
  geom_point(data=m[m$CN == 'loss' & m$value > 0,], aes(y=Gene.Symbols, x=variable), color='green4', size=2, shape=25, fill='green4')


#gc = gene.cnt %>% group_by(Gene.Symbols) %>% summarise(Progressors=sum(Progressors), Non.Progressors=sum(Non.Progressors))
#gc = arrange(subset(gc, Progressors >= Non.Progressors), -Progressors)
#m = melt(gc, id.vars=c('Gene.Symbols'))
#m$Gene.Symbols = factor(m$Gene.Symbols, levels= m$Gene.Symbols[c(nrow(m):1)] ) # order
#ggplot(m, aes(y=Gene.Symbols, x=variable)) + 
#  geom_tile(aes(fill=value), color='white') + 
#  scale_fill_gradient('n patients',low='white',high='royalblue4') + labs(x="",y='CGC Genes')
```


# Is HGD over represented for variable regions?

It's possible that the variable regions we find are entirely within the HGD/IMC samples.  So are they overrepresented?

```{r, hgd, echo=F, message=F, warning=F}

pvnp = data.frame(matrix(nrow=length(subset(sum.patient.data, Status == 'P')$Patient), ncol=2, dimnames=list(subset(sum.patient.data, Status == 'P')$Patient, c('hgd','be'))))    
for (name in subset(sum.patient.data, Status == 'P')$Patient) {
  sn = which(colnames(patient.data[[name]]$variable.regions)[-(1:5)] %in% subset(patient.data[[name]]$info, grepl('HGD|IMC', Pathology))$Samplename)
  if (length(sn) <= 0 | nrow(patient.data[[name]]$variable.regions) <= 0) next
  
  ## HGD
  pvnp[name, 'hgd'] = length(which(patient.data[[name]]$variable.regions[,sn] >= gain.threshold | 
                                patient.data[[name]]$variable.regions[,sn] <= loss.threshold))
  
  # BE-LGD
  pvnp[name, 'be'] = length(which(patient.data[[name]]$variable.regions[-sn] >= gain.threshold | 
                                patient.data[[name]]$variable.regions[-sn] <= loss.threshold))
}

## TODO Check enrichment of variable regions found in BE vs HGD 

tt = t.test(pvnp$hgd, pvnp$be)
pvnp = cbind(pvnp, (pvnp %>% rowwise() %>% mutate(total=hgd+be, hgd.ratio=round(hgd/(hgd+be),3) ))[c('total','hgd.ratio')])

#fisher.test(p, simulate.p.value = T)

ct = cor.test(subset(sum.patient.data, Status == 'P')$total.samples, pvnp$hgd.ratio)

pander(pvnp, justify='left', 
       caption=paste("Number of variable regions found in HGD vs non-HGD samples of progessor patients.  There's no significant difference between them (t-test p=",signif(tt$p.value,2),').  Not all patients have HGD samples (NAs). There is also no significant inverse correlation (r= ',signif(ct$estimate, 2),') between the number/ratio of variable regions found in HGD samples vs non (Pearsons p=',signif(ct$p.value, 2),')',  sep=''))

```

This is just looking at the distribution of values per sample. The average ploidy per sample is around 1.  Currently we're calling variable regions based on this.
```{r, warning=F}
ks = list()
for (pt in names(patient.data)) {
  cols = intersect(arrange(patient.data[[pt]]$info, Pathology, Endoscopy.Year)$Samplename, colnames(patient.data[[pt]]$seg.vals[,-(1:5)]))
  segvals = patient.data[[pt]]$seg.vals[,cols]
  
  sdx = round(apply(segvals, 2, sd), 3)
  se = round(apply(segvals, 2, function(x) sd(x)/sqrt(length(x))), 3)

 gg = ggplot(melt(segvals)) + 
        facet_wrap(~variable,scales = "free_x") + 
        geom_histogram(bins=10, fill='blue', color='grey',aes(value, ..density..)) +
        geom_density(aes(value+sdx/2), color='red', size=1) +
        geom_density(aes(value-sdx/2), color='green', size=1) +
        labs(title=paste(pt, '  (',patient.data[[pt]]$info$Status[1],')', sep=''))
  print(gg)   
  #plots[[pt]] = gg
  
  ks[[pt]] = sapply(segvals, function(x) ks.test(x+sdx, x-sdx)$statistic  )
  print(pt)
  print(colSums(abs(round(patient.data[[pt]]$seg.vals[,-(1:5)], 1)-1)))
}




```


