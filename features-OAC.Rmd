---
title: "Progression Features & OAC"
author: "Sarah Killcoyne"
date: "29 June 2017"
output: 
  html_document: 
    fig_height: 7
    fig_width: 5
    toc: yes
    toc_depth: 4
---

```{r, include=FALSE, warning=F, message=F, echo=F}

library(pander)
library(gridExtra)
library(ggplot2)
library(reshape2)
library(GenomicRanges)
library(ggrepel)
library(ggfortify)
library(readxl)
library(plyr)
library(dplyr)

source('lib/load_patient_metadata.R')

plot.theme = theme(text=element_text(size=14, face='bold'), panel.background=element_blank(), axis.line=element_line(color='black'), panel.grid.major=element_line(color='grey90')) 

## Lists the sequenced patients
sequenced = read_xlsx('~/Documents/OneDrive/OneDrive - MRC Cancer Unit at University of Cambridge/skillcoyne/Documents/Sequencing Batch Info/occams_sequenced_20180426.xlsx')
sequenced = subset(sequenced, grepl('^OC', OCCAMS_ID) )
sequenced$Sample_type = as.factor(tolower(sequenced$Sample_type))
sequenced = subset(sequenced, grepl('barret|normal|tumour', Sample_type))

be.seq = subset(sequenced, grepl('barret', Sample_type))

# n patients sequenced
length(unique(sequenced$OCCAMS_ID))
# ------------------------------ #


# # OCCAMS ID to Illumina ID
# paired = read.table('~/Documents/OneDrive/MRC Cancer Unit at University of Cambridge/icgc group - icgc_shared/icgc-group/batch_progress/reports/g37/PairedOverviewSummary_g37_bwa.txt', header=T, sep='\t', stringsAsFactors = F)
# paired = subset(paired, aligned == '*')
# pairedg37 = subset(paired, OCCAMS %in% unique(sequenced$OCCAMS_ID), select=c('OCCAMS','SampleId'))
# length(unique(pairedg37$OCCAMS))
# 
# paired = read.table('~/Documents/OneDrive/MRC Cancer Unit at University of Cambridge/icgc group - icgc_shared/icgc-group/batch_progress/reports/g1k//PairedOverviewSummary_g1k_bwa.txt', header=T, sep='\t', stringsAsFactors = F)
# paired = subset(paired, aligned == '*')
# pairedg1k = subset(paired, OCCAMS %in% unique(sequenced$OCCAMS_ID), select=c('OCCAMS','SampleId'))
# 
# paired = rbind(pairedg37, pairedg1k)
# paired = unique(paired)
# 
# length(unique(paired$OCCAMS))
# 
# paired[] = lapply(paired[], strip.whitespace)
# length(unique(paired$OCCAMS))
# 
# sp = do.call(rbind, lapply(paired$SampleId, function(x) unlist(strsplit(x, '_vs_'))))
# colnames(sp) = c('tb.sample', 'normal')
# 
# paired = cbind(paired, sp)
# 
# barretts.pairs = subset(paired, tb.sample %in% be.seq$Illumina_Barcode)
# 
# paired = paired[-which(paired$tb.sample %in% be.seq$Illumina_Barcode),]


# ------------------------------ #
# Clinical data
load('~/Data/ICGC/OAC/clinical/labkey_20180111.Rdata', verbose=T)
demo = occams$patients
cols = c(grep('Reason',colnames(demo), value=T),
         grep('Planned',colnames(demo),value=T),
         'FE.EndPoint','RP.Tumor.Size','ST.MainSurgery','RP.HistoryOfNeoAdjuvantTherapy',
         'TR.PalliativeTreatmentModality','TR.CurativeTreatmentModality')
demo[cols] = lapply(demo[cols], as.null)
#demo = oac.demo[unique(sequenced$OCCAMS_ID),]
# ------------------------------ #

# Barrett's adjacency updates from Caitrona
be.updates = data.table::fread("~/Documents/OneDrive/OneDrive - MRC Cancer Unit at University of Cambridge/skillcoyne/OC Data/Barret's Confirmed Data-Caitrona_30092016.txt", stringsAsFactors=F, colClasses=rep('character', 7) )
ba = merge(demo[intersect(rownames(demo), be.updates$`OCCAMS/ID`), c('StudySite','RP.BarrettsAdjacent')], be.updates, by.x='row.names',by.y='OCCAMS/ID') 
rownames(ba) = ba$Row.names

ba = ba[c('RP.BarrettsAdjacent',"Barret's Confirmed")]
colnames(ba) = c('labkey','caitrona')

ba[which(ba$caitrona == ""), 'caitrona'] = NA
ba[which(ba$caitrona == "Y"), 'caitrona'] = "yes"
ba[which(ba$caitrona == "N"), 'caitrona'] = "no"
changed = which(ba[,'labkey'] != ba[,'caitrona'] | is.na(ba[,'labkey']) & !is.na(ba[,'caitrona']))

demo[rownames(ba[changed,]), 'RP.BarrettsAdjacent'] = ba[changed,'caitrona']


# ------------------------------ #

# Tumours
# there are some duplicates in the patient samples so I've selected one tumor for each of those. That means that there are a few less samples to be analysed than the files initially might suggest
tumors = subset(sequenced, Sample_type == 'tumour') 

cnv = read.table('~/Data/ICGC/BE_OAC_Cohort/tumour/data/ascat/totalCNV.txt', sep='\t', header=T, stringsAsFactors=F)

barcodes = do.call(rbind, strsplit(cnv$Illumina.Barcode, '_vs_'))
colnames(barcodes) = c('Tumor.Barcode','Normal.Barcode')

cnv = cbind(cnv, barcodes)
cnv[colnames(barcodes)] = lapply(cnv[colnames(barcodes)], as.character)
length(unique(cnv$Tumor.Barcode))

#subset(tumors, Illumina_Barcode %in% setdiff(cnv$Tumor.Barcode, tumors$Illumina_Barcode))

cnv = base::merge(cnv, tumors, by.x='Tumor.Barcode', by.y='Illumina_Barcode') 

tumorcnv = makeGRangesFromDataFrame(cnv, keep.extra.columns = T)

# Not a problem at the moment
#which(!cnv$Tumor.Barcode %in% tumors$Illumina_Barcode)

# Barretts ADJACENT SAMPLES
becnv = read.table('~/Data/ICGC/BE_OAC_Cohort/BA/data/ascat/totalCNV.txt', sep='\t', header=T, stringsAsFactors=F)
length(unique(becnv$Illumina.Barcode))

barcodes = do.call(rbind, strsplit(becnv$Illumina.Barcode, '_vs_'))
colnames(barcodes) = c('Tumor.Barcode','Normal.Barcode')

becnv = cbind(becnv, barcodes)

becnv[colnames(barcodes)] = lapply(becnv[colnames(barcodes)], as.character)

becnv = base::merge(becnv, subset(sequenced, grepl('barr', Sample_type)) , by.x='Tumor.Barcode', by.y='Illumina_Barcode') 
#becnv = merge(becnv, demo[,cols], by.y='StudySubjectID', by.x='OCCAMS')
becnv = makeGRangesFromDataFrame(becnv, keep.extra.columns = T)
# ------------------------------ #


#oac.demo = subset(demo, StudySubjectID %in% unique(tumorcnv$OCCAMS))
#be.demo = subset(demo, StudySubjectID %in% unique(becnv$OCCAMS))

## Shallow WGS data 
load('~/Data/Ellie/Analysis/5e6_arms_all_exAHM0320/loo.Rdata', verbose=T)
swgsPredictions = pg.samp
rm(pg.samp, plots, coefs, fits)

load('~/Data/Ellie/Analysis/5e6_arms_all_exAHM0320/all.pt.alpha.Rdata', verbose=T)
rawSWGSdf = dysplasia.df
a = '0.9'
coefs = coefs[[a]]; model = models[[a]]

# CV(RR)
hazards = apply( exp(t(rawSWGSdf[, rownames(coefs)])*coefs[,1]), 1, function(x) { sd(x)/mean(x) })
rm(dysplasia.df,models,plots,performance.at.1se)
# ------------------------------ #

ch = as.data.frame(hazards)
ch$coef = coefs[,1]
ch$stability = rowSums(coefs[,-1])/50
ch$label = rownames(ch)

```

# Questions in the Shallow WGS data

Load the coefficients from the selected model and merge with the copynumber regions identified in (some) of the OAC patients
```{r, echo=F, warning=F, message=F}
regions = do.call(rbind.data.frame, c(strsplit(grep('\\d+', ch$label, value=T), ':|-'), stringsAsFactors=F))
colnames(regions) = c('chr','start','stop')
regions[colnames(regions)] = lapply(regions[colnames(regions)], function(x) as.numeric(x))

# Turn SWGs features into grange object
swgRegions = makeGRangesFromDataFrame(cbind.data.frame(regions, ch[grep('\\d+', ch$label),]), keep.extra.columns = T)
swgRegions = swgRegions[order(-swgRegions$hazards)]

ggplot(ch, aes(coef, hazards, col=hazards > quantile(hazards)[['75%']])) + 
  geom_point(alpha=0.5) + 
  geom_text_repel(aes(label=ifelse(hazards > quantile(hazards)[['75%']], label, '')),show.legend=F) +
  labs(title='Top features coef vs hazard') + theme(legend.position = 'none')
```


## Are gains/losses enriched in the coefficients?
We would expect them to be since these are the regions that the model selects as being the best combination to predict P vs NP.

Certainly they are found at a different rate in gains for P vs NP. Which we would expect.

```{r, echo=T}
# positive coefficients were related to gains in progressors
gains = subset(ch, coef > 0)

# counts of gains per coef
gain = do.call(rbind, lapply(gains$label, function(reg) {
  values = rawSWGSdf[,reg] 
  table(labels[which(values > 1)])
}))
rownames(gain) = gains$label
wilcox.test(gain[,1], gain[,2])

# negative coefficients were related to losses in non-progressors
losses = subset(ch, coef < 0)

loss = do.call(rbind, lapply(losses$label, function(reg) {
  values = rawSWGSdf[,reg] 
  table(labels[which(values < -1)])
}))
rownames(loss) = losses$label
wilcox.test(loss[,1], loss[,2])
```

This is true of randomly selected regions as well, which we also expect based on the general trend towards disorder we see in P vs NP.

```{r}
sample.reg = sample(setdiff(colnames(rawSWGSdf), ch$label), nrow(ch))

randomGains = do.call(rbind, lapply(sample.reg, function(reg) {
  values = rawSWGSdf[,reg] 
  table(labels[which(values > 1)])
}))
wilcox.test(randomGains[,1], randomGains[,2])


randomLosses = do.call(rbind, lapply(sample.reg, function(reg) {
  values = rawSWGSdf[,reg] 
  table(labels[which(values < -1)])
}))
wilcox.test(randomLosses[,1], randomLosses[,2])
```


```{r echo=F}
rg = wilcox.test(gain[,'0'], randomGains[,'0'])
rl = wilcox.test(loss[,'0'], randomLosses[,'0'])
```
There appears to be no difference in gains (P=`r rg$p.value`) or losses (P=`r rl$p.value`) for Non-progressors as compared to random.


```{r echo=F}
rg = wilcox.test(gain[,'1'], randomGains[,'1'])
rl = wilcox.test(loss[,'1'], randomLosses[,'1'])
```
However, there is a significant difference in the selected regions for progressors as compared to random (gains P=`r rg$p.value` and losses P=`r rl$p.value`). This is mostly a sanity check.

## Two groups of patients?

There appears to be two groups of patients.

Group 1 is patients that show progression consistently ("born bad")
Group 2 is patients that show sudden progression in the final or nearly final sample

So is there a difference between the two in regards to the alterations in the features drawn from the model?
Or in randomly drawn regions?

```{r}
cutoff = 0.5
status = sapply(swgsPredictions, function(x) unique(x$Status))
transform.pt.by.time<-function(pt) {
  pt = pt %>% group_by(PID, Endoscopy.Year) %>% summarise(
    'pred'=sum(as.integer(Prediction > cutoff)), 'samples'=length(PID), 
    #'final.endo'= length(which(grepl('HGD|IMC', Pathology))) > 0,
    'months.before.final'= (max(pt$Endoscopy.Year) - unique(Endoscopy.Year))*12, 
    'max.path'=max(Pathology))
  arrange(pt, -Endoscopy.Year, PID)
}

back = lapply(swgsPredictions[which(status == 'P')], transform.pt.by.time)

# By sample
fvpS = do.call(rbind.data.frame, lapply(back, function(df) {
  last.sample = (df[1,'pred']/df[1,'samples'])[[1]]
  if (nrow(df) <= 1 | max(df$months.before.final) < 12 ) return(NA)
  cbind('final'=last.sample,  'previous'=sum(df[-1, 'pred']/df[-1, 'samples'])/(nrow(df)-1) )
}))

# Do it by endoscopy? Not sample? And max.path should matter
final.vs.prev = do.call(rbind.data.frame, lapply(back, function(df) {
  last.endo = as.integer(df[1,'pred'] > 0)
  if (nrow(df) <= 1 | max(df$months.before.final) < 12 ) return(NA)
  
  previous = subset(df[-1,], max.path %in% c('BE','ID'))
  cbind('final'=last.endo,  'previous'=sum(as.integer(previous$pred > 0)/(nrow(previous))))
}))


final.vs.prev = final.vs.prev[complete.cases(final.vs.prev),]

m = melt(as.matrix(final.vs.prev))
m = transform(m, Var1=reorder(Var1, -value))           

```

First we want to separate out the patient groups we have. In this table we only include patients that have more than a single sample, and with follow up samples 1 or more years prior to their final (HGD/IMC) sample.

```{r, echo=F}
ggplot(m, aes(x=Var1, y=value,fill=Var2)) + 
  geom_bar(stat="identity", width=.5, position = "dodge") + coord_flip() + 
  labs(title='Ratio of final sample predictions vs all previous samples')
```

For ~~samples~~ endoscopies predicted prior to the final our mean ratio is `r mean(final.vs.prev$previous)` so most are predicted. 
```{r, echo=F}
hist(final.vs.prev$previous)
```

When the final ~~sample~~ endoscopy was not predicted correctly the prediction for previous samples also declines to a mean of `r mean(summary(subset(final.vs.prev, final <= 0)$previous))`.

So the two groups are:

Sudden - predicted at endpoint, but not consistently prior 
```{r}
sudden = subset(final.vs.prev, final > 0 & previous < mean(previous))

pander(sudden, caption='Patients whose final endoscopies were predicted, but prior endoscopies were less clear.')
```

Born bad - predicted consistently prior to endpoint

```{r}
born.bad = subset(final.vs.prev, final > 0 & previous > mean(previous))

pander(born.bad, caption='Patients whose endoscopies were predicted throughout')
```

So how can we compare these?
```{r}
count.losses <- function(x) { length(which(x < -1)) }
count.gains <- function(x) { length(which(x > 1)) }


annotate.by.pt<-function(df) {
  df = df[,c('Prediction','Pathology', 'PID', 'Endoscopy.Year', 'Samplename')]
  df$Prediction = as.integer(df$Prediction > cutoff)
  
  df$Final = df$Pathology %in% c('HGD','IMC') & df$Endoscopy.Year == df$Endoscopy.Year
  df[,c('Prediction','Pathology','Samplename','Final')]
}

sd.pts = do.call(rbind, lapply(swgsPredictions[rownames(sudden)],annotate.by.pt))
bb.pts = do.call(rbind, lapply(swgsPredictions[rownames(born.bad)],annotate.by.pt))

# Can't randomly sample patients here because it's very likely that I'll end up with many of the same patients in both random and sudden/born bad groups
# Could randomly select samples that are not HGD/IMC though...
#rd.pts = do.call(rbind, lapply(swgsPredictions[names(status[which(status == 'P')])],annotate.by.pt))

rd.samp = subset(do.call(rbind, swgsPredictions[names(status[which(status == 'P')])]), Pathology %in% c('BE','ID','LGD'), select=c('Prediction','Pathology','Samplename'))
rd.samp = rd.samp[sample(nrow(rd.samp), 120),]


gains.by.group = cbind.data.frame(
  'sudden'=apply(rawSWGSdf[subset(sd.pts, !Final)$Samplename,gains$label], 2, count.gains),
  'born.bad'=apply(rawSWGSdf[subset(bb.pts, !Final)$Samplename,gains$label], 2, count.gains),
  'random'=apply(rawSWGSdf[rd.samp$Samplename,gains$label], 2, count.gains)
)

losses.by.group = cbind.data.frame(
  'sudden'=apply(rawSWGSdf[subset(sd.pts, !Final)$Samplename,losses$label], 2, count.losses),
  'born.bad'=apply(rawSWGSdf[subset(bb.pts, !Final)$Samplename,losses$label], 2, count.losses),
  'random'=apply(rawSWGSdf[rd.samp$Samplename,losses$label], 2, count.losses)
)
```


This may be driven by the number of samples. I'm not sure if this is correct or how to check at the moment.
In all of these I exclude the "final" sample (typically HGD/IMC).


```{r}
# "born bad" and sudden are different
wilcox.test(gains.by.group$sudden, gains.by.group$born.bad)
wilcox.test(losses.by.group$sudden, losses.by.group$born.bad)

# Random and sudden are different
wilcox.test(gains.by.group$sudden, gains.by.group$random)
wilcox.test(losses.by.group$sudden, losses.by.group$random)

# random and born bad aren't?
wilcox.test(gains.by.group$born.bad, gains.by.group$random) ## not so different
wilcox.test(losses.by.group$born.bad, losses.by.group$random) ## not so different


```

```{r echo=F}
# one-way anova by ranks -- basically the same as wilcox I think
one.way.aov<-function(a, b) {
  df = rbind(cbind.data.frame('counts'=a, 'class'='a'),
             cbind.data.frame('counts'=b, 'class'='b')) 
  kruskal.test(counts~class, data=df)
  #chisq.test(df$counts, df$class)
  #glm(counts~class, data=df, family='poisson')
}
```

So why would random and born bad groups be the same?  Sudden appears to be the only group that stands out in any way, being different from both born bad and random groups.  Sudden has half the samples the other two do, but then random and sudden are different so samplesize should be at issue here.


```{r, echo=F, eval=F}
gains = gains[grep('\\d+',gains$label),]
losses = losses[grep('\\d+',losses$label),]

sd.samples = unlist(lapply(swgsPredictions[rownames(sudden)], function(df) df$Samplename))
bb.samples = unlist(lapply(swgsPredictions[rownames(born.bad)], function(df) df$Samplename))
random.samples = unlist(lapply(swgsPredictions[sample(which(status == 'P'), 15)], function(df) df$Samplename ))

# Born bad losses/gains in features
bbL = apply(rawSWGSdf[bb.samples, losses$label], 2, count.losses)
bbG = apply(rawSWGSdf[bb.samples, gains$label], 2, count.gains)

# sudden losses/gains in features
snL = apply(rawSWGSdf[sd.samples, losses$label], 2, count.losses)
snG = apply(rawSWGSdf[sd.samples, gains$label], 2, count.gains)

# random losses/gains in features
rrL = apply(rawSWGSdf[random.samples, losses$label], 2, count.losses)
rrG = apply(rawSWGSdf[random.samples, gains$label], 2, count.gains)


one.way.aov(bbG, snG)
one.way.aov(bbG, rrG)

one.way.aov(bbL, snL)
one.way.aov(bbL, rrL)

one.way.aov(snL, rrL)
one.way.aov(snG, rrG)
```

```{r, warning=F, message=F, echo=F, fig.width=7, fig.height=10}

totals = melt(cbind.data.frame(
  'sudden'=nrow(subset(sd.pts, !Final)),
  'born.bad'=nrow(subset(bb.pts, !Final)),
  'random'=nrow(rd.samp)))


grid.arrange(
  arrangeGrob(
    ggplot(melt(gains.by.group), aes(variable, value, color=variable, fill=variable)) + geom_jitter(width=0.2) + 
    geom_boxplot(alpha=0.5, outlier.color = NA) + labs(title='Gains', x='', y='counts') + theme(legend.position = 'none'),
  ggplot(melt(losses.by.group), aes(variable, value, color=variable, fill=variable)) + geom_jitter(width=0.2) + 
    geom_boxplot(alpha=0.5, outlier.color = NA) + labs(title='Losses', x='', y='counts') + theme(legend.position = 'none'), ncol=2), 
  
  tableGrob(  rbind(cbind('Group'='Born Bad','# Samples'=nrow(subset(bb.pts, !Final))),
                    cbind('Group'='Sudden','# Samples'=nrow(subset(sd.pts, !Final))),
                    cbind('Group'='Random','# Samples'=nrow(rd.samp)))   ) 
  )


```

### The two groups don't actually exist

TODO  I don't recall what these tests were looking at, need to redo this with the new data

```{r, eval=F}

gains = gains[grep('\\d+',gains$label),]
losses = losses[grep('\\d+',losses$label),]

km = kmeans(rawSWGSdf[c(bb.samples,sd.samples),ch$label], 2)
table(km$cluster)

clusPred = sapply(swgsPredictions[which(status == 'P')], function(df) {
  sum(as.integer(subset(df, Samplename %in% names(which(km$cluster == 1)))$Prediction > cutoff))
})

sum(clusPred)

binom.test(17,17,.72)
names(which(clusPred > 0))
which(rownames(sudden) %in% names(which(clusPred > 0)))
which(rownames(born.bad) %in% names(which(clusPred > 0)))

```




# Questions in OAC data

## Gains

These may be more nuanced, as we need to be aware of gains that reflect WGD vs gains that are new amplifications. At the moment there's no distinction

```{r, fig.height=16, fig.width=16}
plot.gains<-function(df) {
  df = lapply(df, function(x) {
    x = plyr::arrange(x, -width)
    x$order = factor(1:nrow(x))
    return(x)
  })

  m = do.call(rbind.data.frame, df)
  m = m %>% group_by(seqnames) %>% dplyr::ungroup() %>% 
    dplyr::arrange(segment, seqnames, width, start) %>% dplyr::mutate(segorder = row_number()) 
  m$isWGD = as.factor(m$isWGD)

  m$CN = cut(m$Total_CN, include.lowest=T, ordered_result=T, breaks=c(3, 5, 7, 9, 10, max(m$Total_CN)))
  ggplot(data=m, aes(x=order, y=start)) +  
    facet_wrap(~segment, scales='free') +
    geom_segment(aes(x=order, xend=order, y=start, yend=end, color=CN)) + 
    geom_segment(aes(x=0,xend=0, y=seg.start, yend=seg.end), color='red', size=2) +
    scale_colour_brewer(palette='YlGnBu', direction=-1) +
    coord_flip() + plot.theme +
    theme(legend.position='bottom', axis.text=element_blank(),panel.grid.major = element_blank()) + labs(y='chr position', x='Patient', title='Gains')
}
  

# WGD
tumorcnv$isWGD = tumorcnv$ploidy > 3.2 
becnv$isWGD = becnv$ploidy > 3.2

#average genome ploidy <= 2.7 AND total copy number >= 5
#OR average genome ploidy > 2.7 AND total copy number >= 9

gain.for<-function(gg, cnv) {
  ov = findOverlaps(cnv, gg)  
  tmp = cnv[queryHits(ov)]

  if (length(tmp) > 0) {
    #tmp = subset(tmp, ploidy > 2 & Total_CN > round(ploidy))
    tmp = subset(tmp, 
       (!isWGD & Total_CN > round(ploidy)) | 
         (isWGD & Total_CN > round(ploidy+3.2)) )
    if (length(tmp) > 0) {
      tmp$segment = as.character(gg)
      tmp$seg.start = start(gg)
      tmp$seg.end = end(gg)
    }
  }
  as.data.frame(tmp)
}

gr = which(swgRegions$coef > 0)

## gains in patients -- issues with WGD samples?
gains = lapply(as(swgRegions[gr], "GRangesList"), gain.for, cnv=tumorcnv)
names(gains) = as.character(swgRegions[gr])
plot.gains(gains) + labs(title='Gains in OAC samples')


sequenced = base::merge(sequenced, demo, by.x='OCCAMS_ID', by.y='StudySubjectID')
subset(sequenced, RP.BarrettsAdjacent == 'yes')$Illumina_Barcode

be.cnvs = subset(tumorcnv, Tumor.Barcode %in%  subset(sequenced, RP.BarrettsAdjacent == 'yes')$Illumina_Barcode)
non.be.cnvs = subset(tumorcnv, Tumor.Barcode %in%  subset(sequenced, RP.BarrettsAdjacent == 'no')$Illumina_Barcode)

be.gains = lapply(as(swgRegions[gr], 'GRangesList'), gain.for, cnv=be.cnvs)
names(be.gains) = as.character(swgRegions[gr])
plot.gains(be.gains[sapply(be.gains, nrow) > 0]) + labs(title='Gains in BE Adjacent OAC samples') 

non.be.gains = lapply(as(swgRegions[gr], 'GRangesList'), gain.for, cnv=non.be.cnvs)
names(non.be.gains) = as.character(swgRegions[gr])
plot.gains(non.be.gains[sapply(non.be.gains, nrow) > 0]) + labs(title='Gains in Non-BE Adjacent OAC samples') 


```



```{r, fig.height=8, fig.width=12}

# Per patient
gfreq = sort(sapply(gains, function(x) length(unique(x$Illumina.Barcode)))/length(unique(sequenced$OCCAMS_ID)))
ggplot(melt(as.matrix(gfreq)), aes(Var1, value)) + geom_col(fill='darkblue') + ylim(0,0.5) + coord_flip() + 
  labs(x='', y='Frequency', title='Gain frequency in OAC') + theme_bw() + theme(text=element_text(size=14))


gfreq1 = sort(sapply(be.gains, function(x) length(unique(x$Illumina.Barcode)))/length(unique(be.cnvs$Illumina.Barcode)))
gfreq1 = gfreq1[names(gfreq)]


gfreq2 = sort(sapply(non.be.gains, function(x) length(unique(x$Illumina.Barcode)))/length(unique(non.be.cnvs$Illumina.Barcode)))
gfreq2 = gfreq2[names(gfreq)]


m = cbind.data.frame('yes'=gfreq1, 'no'=gfreq2)
m$region = rownames(m)
m = transform(m, region=reorder(region, yes))

ggplot(melt(m), aes(region, value, group=variable, fill=variable)) + facet_grid(~variable) + geom_bar(stat='identity', position=position_dodge(), alpha=0.8) + 
  scale_fill_manual(values=c('dodgerblue3','firebrick3'), name='Barretts Adjacent') +
  coord_flip() + labs(x='', y='Frequency', title="Gain frequency BE vs non") + plot.theme + theme(legend.position = 'bottom')
   

```  


## Losses 

```{r, fig.height=12, fig.width=12}
plot.losses<-function(df) {
  if (!is.data.frame(df)) {
    df = lapply(df, function(x) {
      if(nrow(x) <= 0) return(NULL)
      x = plyr::arrange(x, -width)
      x$order = factor(1:nrow(x))
      return(x)
    })
    m = do.call(rbind.data.frame, df)
  } else {
    m = df
    m = plyr::arrange(m, -width)
    m$order = factor(1:nrow(m))
  }
  #m$segnames = ordered(m$seqnames, levels=c(1:22))

  m = m %>% dplyr::group_by(seqnames) %>% ungroup() %>% dplyr::arrange(segment, seqnames, width, start) %>% dplyr::mutate(segorder = row_number())
  m$isWGD = as.factor(m$isWGD)
  m$CN = as.factor(m$Total_CN)
  #m = transform(m, segment=reorder(segment, segnames))
  p = ggplot(data=m, aes(x=order, y=start)) 
  
  if (length(unique(m$segment)) > 1)
    p = p + facet_wrap(~segment, scales='free')
  
  p + geom_segment(aes(x=order, xend=order, y=start, yend=end, color=CN)) + 
    geom_segment(aes(x=0,xend=0, y=seg.start, yend=seg.end), color='red', size=2) +
    scale_colour_brewer(palette='YlGnBu', direction=1) +
    coord_flip() + plot.theme +
    theme(legend.position='bottom', axis.text=element_blank(), panel.grid.major=element_blank()) + labs(y='chr position', x='Patient', title='Losses in OAC Patients')
}
  

# Losses in patients -- complicated by WGD
##average genome ploidy <= 2.7 AND total copy number = 0
#OR average genome ploidy > 2.7 AND total copy number < ( average genome ploidy - 2.7 )
loss.for<-function(gg, cnv){
  ov = findOverlaps(cnv, gg)  
  tmp = cnv[queryHits(ov)]
  if (length(tmp) > 0) {
    tmp = subset(tmp, (!isWGD & Total_CN == 0) |
                    (isWGD & Total_CN < round(ploidy)) )
    #tmp = tmp[tmp$Total_CN < 2]
    if (length(tmp) > 0) {
      tmp$segment = as.character(gg)
      tmp$seg.start = start(gg)
      tmp$seg.end = end(gg)
    }
  }
  as.data.frame(tmp)
}
  
  
lr = which(swgRegions$coef < 0)

losses = lapply(as(swgRegions[lr], 'GRangesList'), loss.for, tumorcnv)
names(losses) = as.character(swgRegions[lr])
plot.losses(losses)

be.losses = lapply(as(swgRegions[lr], 'GRangesList'), loss.for, be.cnvs)
names(be.losses) = as.character(swgRegions[lr])
plot.losses(be.losses) + labs(title="Losses in (YES) BE Adjacent samples") 

non.be.losses = lapply(as(swgRegions[lr], 'GRangesList'), loss.for, non.be.cnvs)
names(non.be.losses) = as.character(swgRegions[lr])
plot.losses(non.be.losses) + labs(title='Losses in (NO) BE Adjacent samples') 

# grid.arrange(plot.losses(be.losses$`16:76088214-80843726`) + labs(title='BE loss'),
#              plot.losses(non.be.losses$`16:76088214-80843726`) + labs(title='(NO) BE loss') )

```

```{r, fig.height=8, fig.width=12}

lfreq = sort(sapply(losses, function(x) length(unique(x$Illumina.Barcode)))/length(unique(sequenced$OCCAMS_ID)))
ggplot(melt(as.matrix(lfreq)), aes(Var1, value)) + geom_col(fill='darkgreen') + ylim(0,1) + coord_flip() + 
  labs(x='', y='Frequency', title='Loss frequency in OAC') + theme_bw() + theme(text=element_text(size=14))


lfreq1 = sapply(be.losses, function(x) length(unique(x$Illumina.Barcode)))/length(unique(be.cnvs$Illumina.Barcode))
lfreq1 = lfreq1[names(lfreq)]

lfreq2 = sort(sapply(non.be.losses, function(x) length(unique(x$Illumina.Barcode)))/length(unique(non.be.cnvs$Illumina.Barcode)))
lfreq2 = lfreq2[names(lfreq)]


m = cbind.data.frame('yes'=lfreq1, 'no'=lfreq2)
m$region = rownames(m)
m = transform(m, region=reorder(region, yes))

ggplot(melt(m), aes(region, value, group=variable, fill=variable)) + facet_grid(~variable) + geom_bar(stat='identity', position=position_dodge(), alpha=0.8) + 
  scale_fill_manual(values=c('dodgerblue3','firebrick3'), name='Barretts Adjacent') +
  coord_flip() + labs(x='', y='Frequency', title="Loss frequency BE vs non") + plot.theme + theme(legend.position = 'bottom')


```



TODO: This should really separate the focal losses in 17p from the large-scale losses.

```{r fig.height=6,fig.width=8}
chr17 = get.chr.lengths()[17,]

chr17losses = losses[grep('^17:', names(losses))][[1]]

plot.losses(chr17losses) + geom_hline(data=chr17, aes(yintercept=(chr.cent-cent.gap)), color='red', linetype='dashed') +
  labs(y='chr17 position', x='Patient', title='17p Losses in (all) OAC Patients', subtitle=paste(round(length(unique(chr17losses$Illumina.Barcode))/length(unique(tumorcnv$Illumina.Barcode)), 2)*100, '% of OAC patients', sep=''))

```

There does not appear to be a difference in gains vs losses.
```{r}
wilcox.test(sapply(gains, nrow), sapply(losses, nrow))
one.way.aov(sapply(gains, nrow), sapply(losses, nrow))
```

Not between be/non be either
```{r}
wilcox.test(sapply(non.be.gains, nrow), sapply(be.gains, nrow))
wilcox.test(sapply(non.be.losses, nrow), sapply(be.losses, nrow))
```


## Random

Compare those to gains/losses in randomly selected regions of the same size across the genome

```{r, echo=F, warning=F, message=F}
chr.lengths = get.chr.lengths()
chr.lengths$chrom = sub('chr','',chr.lengths$chrom)
chr.lengths$start = 1

genome = makeGRangesFromDataFrame(chr.lengths[1:22,], seqnames.field = 'chrom', end.field='chr.length')
tiles = slidingWindows(genome, width=5e6, step=2.5e6)
chr.samples = sample(length(tiles), length(tiles)/2) # half of the chromosomes
sample.regions = do.call(c, lapply(tiles[chr.samples], function(x) sample(x, length(x)/4)  )) # grab some portion of each
```

### Gains

These may be more nuanced, as we need to be aware of gains that reflect WGD vs gains that are new amplifications. At the moment there's no distinction.

There's no clear difference between the randomly selected regions and gains overall.  But there does appear to be a difference when comparing the randomly selected regions to the regions split by BE/non-BE.  I'm not sure this is real considering the overall case though.

```{r, echo=F}
randomGains = lapply(as(sample.regions,'GRangesList'), gain.for, cnv=tumorcnv)
names(randomGains) = as.character(sample.regions)
randomGains = randomGains[which(sapply(randomGains, nrow) > 2)]


plot.gains(randomGains[sample(length(randomGains), 20)])

# Maybe a difference in # gains in the selected features vs random
# wilcox.test(sapply(randomGains, nrow), sapply(gains, nrow))
# 
# tests = matrix(ncol=2, nrow=10, dimnames=list(c(1:10), c('Rand.vs.BE.Gain', 'Rand.v.Non.Be.Gain')))
# for (i in 1:10) {
#   
#   sr = randomGains[sample(1:length(randomGains), length(be.gains))]
#   wt1 = wilcox.test(sapply(sr, nrow), sapply(be.gains,nrow))
#   
#   sr = randomGains[sample(1:length(randomGains), length(non.be.gains))]
#   wt2 = wilcox.test(sapply(sr, nrow), sapply(non.be.gains,nrow))
#   
#   tests[i,] = c(wt1$p.value, wt2$p.value)
# }
# tests < 0.005
# 
# #wilcox.test(sapply(randomGains, nrow), sapply(be.gains,nrow))
# #wilcox.test(sapply(randomGains, nrow), sapply(non.be.gains,nrow))
# 
# # Not a difference here though
# wilcox.test(sapply(gains, function(df) length(unique(df$Illumina.Barcode))), 
#             sapply(randomGains, function(df) length(unique(df$Illumina.Barcode))))

df = rbind(cbind.data.frame('counts'=sapply(gains, function(df) length(unique(df$Illumina.Barcode))), 'type'='selected') , 
      cbind.data.frame('counts'=sapply(randomGains, function(df) length(unique(df$Illumina.Barcode))), 'type'='random'))
ggplot(df, aes(type, counts, group=type, fill=type)) + geom_boxplot() + geom_jitter(width=0.3) + labs(title='Patient counts by region') + plot.theme


df = rbind(cbind.data.frame('counts'=sapply(gains, nrow), 'type'='selected') , 
      cbind.data.frame('counts'=sapply(randomGains, nrow), 'type'='random'))
ggplot(df, aes(type, counts, group=type, fill=type)) + geom_boxplot() + geom_jitter(width=0.3) + labs(title='Gain counts per region') + plot.theme

```


```{r, echo=T}
df = rbind(cbind.data.frame('counts'=sapply(non.be.gains, nrow), 'type'='non.be'),
           cbind.data.frame('counts'=sapply(be.gains, nrow), 'type'='be'),
           cbind.data.frame('counts'=sapply(gains, nrow), 'type'='all.selected'),
           cbind.data.frame('counts'=sapply(randomGains, nrow), 'type'='random'))
ggplot(df, aes(type, counts, group=type, fill=type, color=type)) + geom_boxplot(alpha=0.5, outlier.colour = NA) + 
  geom_jitter(width=0.3) + labs(title='Gain counts per region') + plot.theme


wilcox.test(subset(df, type == 'random')$counts, subset(df, type == 'be')$counts)
wilcox.test(subset(df, type == 'random')$counts, subset(df, type == 'non.be')$counts)
wilcox.test(subset(df, type == 'random')$counts, subset(df, type == 'all.selected')$counts)


```



### Losses

```{r, echo=F}
randomLosses = lapply(as(sample.regions,'GRangesList'), loss.for, cnv=tumorcnv)
names(randomLosses) = as.character(sample.regions)

randomLosses = randomLosses[which(sapply(randomLosses, nrow) > 2)]

plot.losses(randomLosses[sample(length(randomLosses), 15)])

# Definite difference between the numbers of gains and losses in randomly selected regions
wilcox.test(sapply(randomGains, nrow), sapply(randomLosses, nrow))

# # No difference in # losses in the selected features
# wilcox.test(sapply(randomLosses, nrow), sapply(losses, nrow))
# 
# 
# tests = matrix(ncol=2, nrow=10, dimnames=list(c(1:10), c('Rand.vs.BE.Loss', 'Rand.v.Non.Be.Loss')))
# for (i in 1:10) {
#   sr = randomLosses[sample(1:length(randomLosses), length(be.losses))]
#   wt1 = wilcox.test(sapply(sr, nrow), sapply(be.losses,nrow))
#   
#   sr = randomLosses[sample(1:length(randomLosses), length(non.be.losses))]
#   wt2 = wilcox.test(sapply(sr, nrow), sapply(non.be.losses,nrow))
#   
#   tests[i,] = c(wt1$p.value, wt2$p.value)
# }
# tests < 0.005


# No difference between the two
df = rbind(cbind.data.frame('counts'=sapply(losses, function(df) length(unique(df$Illumina.Barcode))), 'type'='selected') , 
      cbind.data.frame('counts'=sapply(randomLosses, function(df) length(unique(df$Illumina.Barcode))), 'type'='random'))
ggplot(df, aes(type, counts, group=type, fill=type)) + geom_boxplot() + geom_jitter(width=0.3) + labs(title='Loss counts by patient') + plot.theme



df = rbind(cbind.data.frame('counts'=sapply(non.be.losses, nrow), 'type'='non.be'),
           cbind.data.frame('counts'=sapply(be.losses, nrow), 'type'='be'),
           cbind.data.frame('counts'=sapply(losses, nrow), 'type'='all.selected'),
           cbind.data.frame('counts'=sapply(randomLosses, nrow), 'type'='random'))
ggplot(df, aes(type, counts, group=type, fill=type, color=type)) + geom_boxplot(alpha=0.5) + 
  geom_jitter(width=0.3) + labs(title='Loss counts per region') + plot.theme


```

## Focal vs Large CN

It's worth looking to see if focal/large changes are enriched in the gains particularly as the plots seemed to suggest they may be.

#### Gains

```{r, echo=F, fig.width=8}
size = unlist(sapply(gains, function(df) df$width))
hist(size)
abline(v = 3e6, col='red')

#chr.lengths$chr.length*.01


# Focal changes < 1% or the chromosome?
countBySize <-function(df) {
  s = round(subset(chr.lengths, chrom == unique(df$seqnames))$chr.length *.01)
  cbind('focal'=nrow(subset(df, width < s)),
        'large'=nrow(subset(df, width >= s)))
}

sizebyPatient<-function(df) {
  s = round(subset(chr.lengths, chrom == unique(df$seqnames))$chr.length *.01)
  cbind('focal'=length(unique(subset(df, width < s)$OCCAMS)),
        'large'=length(unique(subset(df, width >= s)$OCCAMS)))
}

# sizebyPatient<-function(x) {
#   cbind('focal'=length(unique(subset(x, width <= quantile(width)[['25%']])$OCCAMS)),
#         'large'=length(unique(subset(x, width > quantile(width)[['25%']])$OCCAMS)) )
# }

# countBySize<-function(x) {
#   cbind('focal'=nrow(subset(x, width < quantile(width)[['25%']])),
#         'large'=nrow(subset(x, width >= quantile(width)[['25%']])) )
# }

## Still in the regions selected
sizeGainsByPatient = do.call(rbind.data.frame,lapply(gains, sizebyPatient))
sizeGains = do.call(rbind.data.frame,lapply(gains, countBySize))

#  enrichment for some focal changes
x = which(p.adjust(apply(sizeGains, 1, function(x) binom.test(x[1], sum(x), 0.5)$p.value )) < 0.05)
# CI
apply(sizeGains, 1, function(x) binom.test(x[1], sum(x), 0.5)$conf.int )[,x]


## Not sure what to do with this really. Regions are shared, nonBE has two additional
sizeGainsBE = do.call(rbind.data.frame, lapply(be.gains, countBySize))
which(p.adjust(apply(sizeGainsBE, 1, function(x) binom.test(x[1], sum(x), 0.5)$p.value )) < 0.05)
sizeGainsNonBE = do.call(rbind.data.frame, lapply(non.be.gains, countBySize))
which(p.adjust(apply(sizeGainsNonBE, 1, function(x) binom.test(x[1], sum(x), 0.5)$p.value )) < 0.05)


# Same is true for gains of type by patient
xx = which(p.adjust(apply(sizeGainsByPatient, 1, function(x) binom.test(x[1], sum(x), 0.5)$p.value )) < 0.05)
apply(sizeGainsByPatient, 1, function(x) binom.test(x[1], sum(x), 0.5)$conf.int )[,xx]


## Not sure what to do with this really. Again shared regions, two addition in the nonBE
sizeGainsBEByPt = do.call(rbind.data.frame, lapply(be.gains, sizebyPatient))
which(p.adjust(apply(sizeGainsBEByPt, 1, function(x) binom.test(x[1], sum(x), 0.5)$p.value )) < 0.05)
sizeGainsNonBEByPt = do.call(rbind.data.frame, lapply(non.be.gains, sizebyPatient))
which(p.adjust(apply(sizeGainsNonBEByPt, 1, function(x) binom.test(x[1], sum(x), 0.5)$p.value )) < 0.05)


## TODO Here we need to compare to randomly selected regions. I don't think you'd expect that regions with many focal would also show large  or vice versa
sizeGainsRatio = sizeGains %>% rowwise() %>% dplyr::summarise( 'focal.r'=focal/sum(focal,large), 'large.r'=large/sum(focal,large) )
sizeGainsRatio$feature = rownames(sizeGains)

grid.arrange(
  ggplot(melt(sizeGainsRatio), aes(feature, value, fill=variable) ) + geom_col() + coord_flip() + labs(title='Ratio of overall gains per region'),
  ggplot(melt(sizeGainsByPatient), aes(variable, value, group=variable, fill=variable)) + 
    geom_boxplot(alpha=0.5, outlier.colour = NA) + geom_jitter(width=0.2, aes(color=variable)) + 
    labs(title="Patients per region", subtitle=paste('p=',format.pval(one.way.aov(sizeGainsByPatient$focal, sizeGainsByPatient$large)$p.value,digits=3), sep=''), y='patients per region', x=''),
top='Gains in selected regions', ncol=2)
```

#### Losses

```{r, echo=F, fig.width=8}
sizeLossesByPatients = do.call(rbind.data.frame,lapply(losses, sizebyPatient))
sizeLosses = do.call(rbind.data.frame,lapply(losses, countBySize))

sizeLossBE = do.call(rbind.data.frame, lapply(be.losses, countBySize))
sizeLossNoBE = do.call(rbind.data.frame, lapply(non.be.losses, countBySize))

wilcox.test(sizeLossBE$large, sizeLossNoBE$large)

# True for losses as well
which(p.adjust(apply(sizeLosses, 1, function(x) binom.test(x[1], sum(x), 0.5)$p.value )) < 0.05)
apply(sizeLosses, 1, function(x) binom.test(x[1], sum(x), 0.5)$conf.int )

## Again, wouldn't expect a lot of focal losses if there are large ones already so need to think about what to test
sizeLossRatio = sizeLosses %>% rowwise() %>% summarise( 'focal.r'=focal/sum(focal,large), 'large.r'=large/sum(focal,large) )
sizeLossRatio$feature = rownames(sizeLosses)

ggplot(melt(sizeLossRatio, id.vars='feature'), aes(feature, value, fill=variable) ) + geom_col() + coord_flip() + labs(title='Overall losses')

grid.arrange(
ggplot(melt(sizeLosses), aes(variable, value, group=variable, fill=variable)) + 
  geom_boxplot(alpha=0.5, outlier.colour = NA) + geom_jitter(width=0.2, aes(color=variable)) + 
  labs(title="Counts per region", subtitle=paste('p=',format.pval(one.way.aov(sizeLosses$focal, sizeLosses$large)$p.value,3), sep=''), y='counts per region', x=''),

ggplot(melt(sizeLossesByPatients), aes(variable, value, group=variable, fill=variable)) + 
  geom_boxplot(alpha=0.5, outlier.colour = NA) + geom_jitter(width=0.2, aes(color=variable)) + 
  labs(title="Patients per region", subtitle=paste('p=',format.pval(one.way.aov(sizeLossesByPatients$focal, sizeLossesByPatients$large)$p.value,3), sep=''), y='patients per region', x=''),
top='Losses in selected regions', ncol=2)

```


### Compared to random focal/large changes?

#### Losses

Basically losses tend to be large (>1% of the chromosome) and patients are more likely to have large losses rather than focal ones

```{r, echo=F, fig.width=8}
randomLossesByPt = do.call(rbind.data.frame,lapply(randomLosses, sizebyPatient))
randomLossesBySize = do.call(rbind.data.frame,lapply(randomLosses, countBySize))

grid.arrange(
ggplot(melt(randomLossesBySize), aes(variable, value, group=variable, fill=variable)) + 
  geom_boxplot(alpha=0.5, outlier.colour = NA) + geom_jitter(width=0.2, aes(color=variable)) + 
  labs(title="Counts per region", subtitle=paste('p=',format.pval(one.way.aov(randomLossesBySize$focal, randomLossesBySize$large)$p.value,digits=3), sep=''), y='counts per region', x='') + theme(legend.position = 'none'),

ggplot(melt(randomLossesByPt), aes(variable, value, group=variable, fill=variable)) + 
  geom_boxplot(alpha=0.5, outlier.colour = NA) + geom_jitter(width=0.2, aes(color=variable)) + 
  labs(title="Patients per region", subtitle=paste('p=',format.pval(one.way.aov(randomLossesByPt$focal, randomLossesByPt$large)$p.value,digits=3), sep=''), y='patients per region', x='') + theme(legend.position = 'none'),
top='Losses in randomly selected regions', ncol=2)


# No real difference in randomly selected regions for focal losses
wilcox.test(randomLossesBySize$focal, sizeLosses$focal) 
#one.way.aov(randomLossesBySize$focal, sizeLosses$focal) 

## Difference in large losses
wilcox.test(randomLossesBySize$large, sizeLosses$large)
#one.way.aov(randomLossesBySize$large, sizeLosses$large)
```


#### Gains

Looks like gains show no particular enrichment for focal vs large alterations.

```{r, echo=F, fig.width=8}
randomGainsByPt = do.call(rbind.data.frame,lapply(randomGains, sizebyPatient))
randomGainsBySize = do.call(rbind.data.frame,lapply(randomGains, countBySize))

grid.arrange(
ggplot(melt(randomGainsBySize), aes(variable, value, group=variable, fill=variable)) + 
  geom_boxplot(alpha=0.5, outlier.colour = NA) + geom_jitter(width=0.2, aes(color=variable)) + 
  labs(title="Counts per region", subtitle=paste('p=',format.pval(one.way.aov(randomGainsBySize$focal, randomGainsBySize$large)$p.value,3), sep=''), y='counts per region', x='') + theme(legend.position = 'none'),

ggplot(melt(randomGainsByPt), aes(variable, value, group=variable, fill=variable)) + 
  geom_boxplot(alpha=0.5, outlier.colour = NA) + geom_jitter(width=0.2, aes(color=variable)) + 
  labs(title="Patients per region", subtitle=paste('p=',format.pval(one.way.aov(randomGainsByPt$focal, randomGainsByPt$large)$p.value,3), sep=''), y='patients per region', x='') + theme(legend.position = 'none'),
top='Gains in randomly selected regions', ncol=2)


wilcox.test(randomGainsBySize$focal, sizeGains$focal) 
wilcox.test(randomGainsBySize$large, sizeGains$large) 
wilcox.test(sizeGainsByPatient$focal, sizeGainsByPatient$large) 

```

# Cox 

```{r}
library(survival)
library(GGally)


oac.demo = subset(demo, StudySubjectID %in% sequenced$OCCAMS_ID)


pt.gains = do.call(rbind, lapply(oac.demo$StudySubjectID, function(id) {
  rbind(sapply(gains, function(g)  nrow(subset(g, OCCAMS_ID == id))))
}))
rownames(pt.gains) = oac.demo$StudySubjectID
colnames(pt.gains) = paste('gain_', gsub(':|-', '\\.', colnames(pt.gains)), sep='')
  
pt.losses = do.call(rbind, lapply(oac.demo$StudySubjectID, function(id) {
  rbind(sapply(losses, function(g)  nrow(subset(g, OCCAMS_ID == id))))
}))
rownames(pt.losses) = oac.demo$StudySubjectID
colnames(pt.losses) = paste('loss_',gsub(':|-', '\\.', colnames(pt.losses)), sep='')

demo.cols = c('StudySubjectID','Weeks.Survival', 'FE.Patient.Died', 'RP.BarrettsAdjacent', 'DI.PatientGender', 'DI.ageAtDiagnosis', 'RP.TStage.PrimaryTumour', 'RP.TumourDifferentiation', 'RP.Tumour.Growth')

x = merge(pt.gains, pt.losses, by='row.names', all=T)

x = base::merge(x,oac.demo[,demo.cols], by.x='Row.names', by.y='StudySubjectID')
x$Row.names = NULL

time = 'Weeks.Survival';  event='FE.Patient.Died'; type = '"right"'
x[c(time,event)] = lapply(x[c(time,event)], as.numeric)

x$RP.TStage.PrimaryTumour = as.character(x$RP.TStage.PrimaryTumour)

x[grepl('T1', x$RP.TStage.PrimaryTumour), 'RP.TStage.PrimaryTumour'] = 'T1'
x[grepl('T4', x$RP.TStage.PrimaryTumour), 'RP.TStage.PrimaryTumour'] = 'T4'
x[grepl('Tx', x$RP.TStage.PrimaryTumour), 'RP.TStage.PrimaryTumour'] = 'T0'


terms = as.formula(paste("Surv(",time,",",event,", type=",type,") ~ RP.BarrettsAdjacent", sep=""))
sfit = survfit(terms, data=x,conf.int=0.95, conf.type='log', na.action=na.omit)
ggsurv(sfit)


#f1 = paste(demo.cols[c(3,5:7)], collapse='+')
f1 = paste(demo.cols[4:6], collapse='+')
f2 = paste(paste('`', grep('^gain|loss', colnames(x), value=T), '`', sep=''), collapse='+')
f = paste(f1,f2, sep='+')

terms = as.formula(paste("Surv(",time,",",event,", type=",type,") ~", f, sep=""))
cox = coxph(terms, data=x,na.action=na.omit,ties='breslow')
cfit = survfit(cox)
summary(cox)
ggsurv(cfit) + labs(title=paste(length(grep('gain|loss', colnames(x))), 'copy number + demo'))

pander(cox)

anova(cox)
```



```{r}
library(CoxHD)


x = x[,c(grep('gain|loss',colnames(x), invert=T), grep('gain|loss',colnames(x)))]
xs = x

xs = xs[,grep('Tumour', colnames(xs), invert=T)]



surv = with(xs, Surv(Weeks.Survival, FE.Patient.Died))
ggsurv(survfit(surv~1,data=xs))

xs = xs[,-grep('Weeks|Died',colnames(xs))]

xs$RP.BarrettsAdjacent = as.integer(xs$RP.BarrettsAdjacent)-1
#xs$RP.TStage.PrimaryTumour = as.integer(factor(xs$RP.TStage.PrimaryTumour))-1
#xs$RP.TumourDifferentiation = as.integer(factor(xs$RP.TumourDifferentiation))-1
xs$DI.PatientGender = as.integer(as.factor(xs$DI.PatientGender))-1


groups = c(rep('clin', 3), rep('cn',(ncol(pt.gains)+ncol(pt.losses)) ))

rfx = CoxRFX(xs, surv, groups, nu=1, verbose=T)
summary(rfx)

plot(rfx)

VarianceComponents(rfx)

WaldTest(rfx)

PartialC(rfx)

PlotVarianceComponents(rfx)

```



*** 
# Summary to this point

Between the regions selected by the SWGs work and randomly selected regions of the same size across the genome only losses appear to show a difference in the rate of CN suggesting some enrichment in the selected regions.  It's possible that gains need to be broken down differently, for instance separating out gains after WGD vs gains pre-WGD.  For this I need to apply a clonal analysis timing (Mortiz's work).

There's a significant difference in the rate of large-scale alterations vs focal for both gains and losses, but again no difference in gains between selected and random regions, only in losses.  This should be reanalysed based on WGD timing as well.

***

